"""
This type stub file was generated by pyright.
"""

import torch
import sympy
from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING, Union
from torch import SymInt
from torch.fx.experimental.sym_node import SymNode
from torch.types import PySymType
from torch.utils._backport_slots import dataclass_slots
from torch.fx.experimental.symbolic_shapes import ShapeEnv
from .fake_tensor import _DispatchCacheKey, _MetadataIntLike

if TYPE_CHECKING:
    ...
@dataclass_slots
@dataclass(frozen=True)
class _DeconstructedSymNode:
    """
    Represents a SymNode without the associated ShapeEnv
    """
    _expr: sympy.Expr
    pytype: type
    _hint: Optional[Union[int, float, bool]]
    constant: Optional[Union[int, float, bool]]
    fx_node: torch.fx.Node
    @staticmethod
    def from_node(node: SymNode) -> _DeconstructedSymNode:
        ...
    
    def extract(self, shape_env: ShapeEnv) -> SymNode:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


@dataclass_slots
@dataclass(frozen=True)
class _DeconstructedSymType:
    """
    Represents a SymInt, SymFloat, SymBool without the associated ShapeEnv
    """
    ty: type[PySymType]
    node: _DeconstructedSymNode
    @staticmethod
    def from_sym_type(value: PySymType) -> _DeconstructedSymType:
        ...
    
    def extract(self, shape_env: ShapeEnv) -> PySymType:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


@dataclass_slots
@dataclass(frozen=True)
class _InputBackref:
    value: int
    ...


@dataclass_slots
@dataclass
class _PySymInputStub:
    """
    Represents a SymInt in the cached key. Needed because SymInt doesn't
    support __eq__ or __hash__ directly.
    """
    value: Union[PySymType, _DeconstructedSymType, _InputBackref]
    def __init__(self, value: Union[PySymType, _DeconstructedSymType, _InputBackref]) -> None:
        ...
    
    def strip_shape_env(self) -> None:
        ...
    
    def extract(self, shape_env: ShapeEnv) -> PySymType:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


@dataclass_slots
@dataclass
class _SymIntOutputStub:
    """
    Represents a SymInt in the cached output.
    """
    value: Union[int, _DeconstructedSymNode]
    def __init__(self, value: SymInt, key_path: Optional[int]) -> None:
        ...
    
    def extract(self, key: _DispatchCacheKey, shape_env: ShapeEnv) -> SymInt:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


@dataclass_slots
@dataclass
class _CacheKeyState:
    """
    State used while building our cache key.
    """
    sym_node_lookup: dict[int, int]
    known_symbols: set[sympy.Symbol]
    shape_env: Optional[ShapeEnv]
    def __init__(self, shape_env: Optional[ShapeEnv] = ...) -> None:
        ...
    
    def cache_on_shape_env(self) -> bool:
        """
        Returns true if the CacheKey needs to be cached on the ShapeEnv
        rather than the global cache.

        If our inputs contain a SymNode then we can't cache this operation on
        the global cache because the cached output will implicitly depend on
        guard values which might not be true on some other ShapeEnv. So unless
        we're also going to cache the guards we need to cache this operation on
        the ShapeEnv instead of globally.
        """
        ...
    
    def convert_sym_int(self, result: list[object], arg: SymInt) -> None:
        ...
    
    def convert_output(self, arg: _MetadataIntLike) -> _MetadataIntLike:
        ...
    


