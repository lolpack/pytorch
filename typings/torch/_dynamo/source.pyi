"""
This type stub file was generated by pyright.
"""

import dataclasses
import enum
import functools
from typing import Any, Optional, TYPE_CHECKING, Union
from torch._guards import ChainedSource, Source
from .codegen import PyCodegen

"""
This module provides Source classes that track the origins of values in PyTorch Dynamo.
Sources represent where values come from (e.g. local variables, globals, attributes) and
are used for guard generation and code reconstruction during compilation.

The module includes specialized sources for:
- Local variables and synthetic locals
- Global variables and constants
- Object attributes and method calls
- NN module specialization (specialized vs unspecialized)
- Random values and tensor properties
- Default argument handling
- FSDP (Fully Sharded Data Parallel) modules

Sources play a key role in Dynamo's guard system by tracking value origins for
guard generation, and in code reconstruction by providing methods to rebuild
the code needed to recreate values.
"""
if TYPE_CHECKING:
    ...
_GUARD_SOURCE_SPECIALIZED_NN_MODULE = ...
_GUARD_SOURCE_UNSPECIALIZED_NN_MODULE = ...
_GUARD_SOURCE_UNSPECIALIZED_BUILTIN_NN_MODULE = ...
_GUARD_SOURCE_FSDP_MODULE = ...
def is_constant_source(source): # -> bool:
    ...

@dataclasses.dataclass(frozen=True)
class LocalSource(Source):
    local_name: str
    is_input: bool = ...
    dynamism: Optional[frozenset[str]] = ...
    is_derefed_cell_contents: bool = ...
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.LOCAL]:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class SyntheticLocalSource(Source):
    local_name: str
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.SYNTHETIC_LOCAL]:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class RandomValueSource(Source):
    random_call_index: int
    def guard_source(self): # -> Literal[GuardSource.RANDOM_VALUE]:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class GlobalSource(Source):
    global_name: str
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.GLOBAL]:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class GlobalWeakRefSource(Source):
    global_name: str
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.GLOBAL]:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class WeakRefCallSource(ChainedSource):
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class CallFunctionNoArgsSource(WeakRefCallSource):
    ...


@dataclasses.dataclass(frozen=True)
class AttrSource(ChainedSource):
    member: str
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class GenericAttrSource(ChainedSource):
    member: str
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class LocalCellSource(Source):
    """
    Conceptually, this class is `LocalSource` for cell objects implicitly
    generated by Python (e.g., captured variables).
    """
    local_name: str
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


@dataclasses.dataclass(frozen=True)
class GradSource(ChainedSource):
    member: str = ...
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class ParamBufferSource(AttrSource):
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class UnspecializedParamBufferSource(AttrSource):
    ...


@dataclasses.dataclass(frozen=True)
class EphemeralSource(Source):
    desc: Optional[str] = ...
    def guard_source(self): # -> Literal[GuardSource.EPHEMERAL]:
        ...
    
    def name(self): # -> str:
        ...
    
    def make_guard(self, fn):
        ...
    
    def is_ephemeral(self): # -> Literal[True]:
        ...
    


class TensorProperty(enum.Enum):
    SIZE = ...
    STRIDE = ...
    STORAGE_OFFSET = ...
    def method_name(self): # -> Literal['size', 'stride', 'storage_offset'] | None:
        ...
    


@dataclasses.dataclass(frozen=True)
class TensorPropertySource(ChainedSource):
    prop: TensorProperty
    idx: Optional[int] = ...
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class IndexedSource(ChainedSource):
    idx: int
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen):
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class NegateSource(ChainedSource):
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen):
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class ConvertIntSource(ChainedSource):
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class FlattenScriptObjectSource(ChainedSource):
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class ScriptObjectQualifiedNameSource(ChainedSource):
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


class AttrProxySource(ChainedSource):
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class DefaultsSource(ChainedSource):
    idx_key: Union[int, str]
    is_kw: bool = ...
    field: str = ...
    _name: str = ...
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class GetItemSource(ChainedSource):
    index: Any
    index_is_slice: bool = ...
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def unpack_slice(self): # -> Any:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class ConstDictKeySource(ChainedSource):
    index: Any
    def guard_source(self): # -> GuardSource:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def name(self): # -> str:
        ...
    
    def is_dict_key(self): # -> Literal[True]:
        ...
    


@dataclasses.dataclass(frozen=True)
class DictGetItemSource(ChainedSource):
    index: Any
    def __post_init__(self): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class DictSubclassGetItemSource(ChainedSource):
    index: Any
    def __post_init__(self): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class ListGetItemSource(GetItemSource):
    """
    Same as GetItemSource with reconstruct and name overridden to be list specific.
    """
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class TupleIteratorGetItemSource(GetItemSource):
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class TypeSource(ChainedSource):
    def __post_init__(self): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class OptimizerSource(ChainedSource):
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class NNModuleSource(ChainedSource):
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def name(self): # -> str:
        ...
    


@dataclasses.dataclass(frozen=True)
class UnspecializedNNModuleSource(NNModuleSource):
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class UnspecializedBuiltinNNModuleSource(UnspecializedNNModuleSource):
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class FSDPNNModuleSource(NNModuleSource):
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class GlobalStateSource(Source):
    def name(self): # -> Literal['']:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.GLOBAL]:
        ...
    


@dataclasses.dataclass(frozen=True)
class TorchFunctionModeStackSource(Source):
    ind: int
    def name(self): # -> str:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.GLOBAL]:
        ...
    


@dataclasses.dataclass(frozen=True)
class ConstantSource(Source):
    source_name: str
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.CONSTANT]:
        ...
    
    def name(self): # -> str:
        ...
    
    def make_guard(self, fn):
        ...
    


@dataclasses.dataclass(frozen=True)
class NumpyTensorSource(ChainedSource):
    def name(self) -> str:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


@dataclasses.dataclass(frozen=True)
class SubclassAttrListSource(ChainedSource):
    def name(self) -> str:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class FloatTensorSource(ChainedSource):
    def name(self) -> str:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class CallMethodItemSource(ChainedSource):
    def name(self) -> str:
        ...
    
    def guard_source(self): # -> GuardSource:
        ...
    


@dataclasses.dataclass(frozen=True)
class ShapeEnvSource(Source):
    def name(self): # -> Literal['']:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.SHAPE_ENV]:
        ...
    


@dataclasses.dataclass(frozen=True)
class BackwardStateSource(Source):
    def name(self): # -> Literal['']:
        ...
    
    def guard_source(self): # -> Literal[GuardSource.BACKWARD_STATE]:
        ...
    


def get_local_source_name(source: Source, *, only_allow_input=...) -> Optional[str]:
    ...

def is_from_local_source(source: Source, *, only_allow_input=...): # -> bool:
    ...

def is_from_global_source(source: Source) -> bool:
    ...

def get_global_source_name(source: Source) -> Optional[str]:
    ...

def is_from_nonlocal_source(source: Source): # -> bool:
    ...

def is_from_source(source: Source, target: Source): # -> bool:
    ...

@functools.lru_cache
def is_from_unspecialized_nn_module_source(source: Source): # -> bool:
    ...

@functools.lru_cache
def is_from_unspecialized_builtin_nn_module_source(source: Source): # -> bool:
    ...

@functools.lru_cache
def is_from_unspecialized_param_buffer_source(source: Source): # -> bool:
    ...

@functools.lru_cache
def is_from_flatten_script_object_source(source: Source): # -> bool:
    ...

@functools.lru_cache
def is_from_optimizer_source(source: Source): # -> bool:
    ...

@functools.lru_cache
def is_from_defaults(source: Source): # -> bool:
    ...

