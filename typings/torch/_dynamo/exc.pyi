"""
This type stub file was generated by pyright.
"""

import typing
import types
from enum import Enum
from traceback import StackSummary
from typing import Any, NoReturn, Optional, TYPE_CHECKING
from torch._guards import CompileId
from .symbolic_convert import InstructionTranslatorBase
from .types import DynamoFrameType

if TYPE_CHECKING:
    ...
def exportdb_error_message(case_name: str) -> str:
    ...

log = ...
graph_breaks_log = ...
class TorchDynamoException(RuntimeError):
    ...


class InternalTorchDynamoError(TorchDynamoException):
    ...


class ResumePrologueTracingError(TorchDynamoException):
    ...


class RestartAnalysis(TorchDynamoException):
    restart_reason: Optional[str]
    def __init__(self, *args: Any, restart_reason: Optional[str] = ...) -> None:
        ...
    


class SpeculationRestartAnalysis(RestartAnalysis):
    ...


class UnspecializeRestartAnalysis(RestartAnalysis):
    ...


class CompileCollectiveRestartAnalysis(RestartAnalysis):
    ...


class TensorifyScalarRestartAnalysis(RestartAnalysis):
    ...


class SkipFrame(TorchDynamoException):
    ...


class TorchRuntimeError(TorchDynamoException):
    ...


class InvalidBackend(TorchDynamoException):
    def __init__(self, name: str) -> None:
        ...
    


class ResetRequired(TorchDynamoException):
    def __init__(self) -> None:
        ...
    


class ShortenTraceback(TorchDynamoException):
    def __init__(self, *args: Any, first_useful_frame: Optional[types.FrameType], **kwargs: Any) -> None:
        ...
    
    def remove_dynamo_frames(self) -> typing.Self:
        ...
    


class BackendCompilerFailed(ShortenTraceback):
    def __init__(self, backend_fn: Any, inner_exception: Exception, first_useful_frame: Optional[types.FrameType]) -> None:
        ...
    


class Unsupported(TorchDynamoException):
    def __init__(self, msg: str, *, case_name: Optional[str] = ...) -> None:
        ...
    
    def remove_from_stats(self) -> None:
        ...
    
    def add_to_stats(self, category: str = ...) -> None:
        ...
    


class UnknownPropertiesDuringBackwardTrace(Unsupported):
    ...


class RecompileError(TorchDynamoException):
    ...


class ArgsMismatchError(Unsupported):
    def __init__(self, msg: str) -> None:
        ...
    


class AttributeMutationError(Unsupported):
    def __init__(self, msg: str) -> None:
        ...
    


class InfiniteGeneratorError(Unsupported):
    def __init__(self, msg: str) -> None:
        ...
    


class SideEffectsError(Unsupported):
    def __init__(self, msg: str) -> None:
        ...
    


class CondOpArgsMismatchError(ArgsMismatchError):
    """
    Internal error from cond() due to arguments mismatch.
    """
    def __init__(self, msg: str) -> None:
        ...
    


class UserErrorType(Enum):
    DYNAMIC_CONTROL_FLOW = ...
    ANTI_PATTERN = ...
    STANDARD_LIBRARY = ...
    CONSTRAINT_VIOLATION = ...
    DYNAMIC_DIM = ...
    INVALID_INPUT = ...
    INVALID_OUTPUT = ...
    UNSUPPORTED_ALIASED_MUTATED_DYNAMIC_INPUTS = ...


class UserError(Unsupported):
    def __init__(self, error_type: UserErrorType, msg: str, case_name: Optional[str] = ...) -> None:
        """
        Type of errors that would be valid in Eager, but not supported in TorchDynamo.
        The error message should tell user about next actions.

        error_type: Type of user error
        msg: Actionable error message
        case_name: (Optional) Unique name (snake case) for the usage example in exportdb.
        """
        ...
    


class SkipCodeRecursiveException(TorchDynamoException):
    ...


class RecompileLimitExceeded(Unsupported):
    ...


class UnsafeScriptObjectError(TorchDynamoException):
    ...


class UncapturedHigherOrderOpError(TorchDynamoException):
    ...


class IncorrectUsage(Exception):
    ...


class FailOnRecompileLimitHit(Exception):
    ...


class PackageError(TorchDynamoException):
    ...


class ObservedException(TorchDynamoException):
    ...


class ObservedUserStopIteration(ObservedException):
    value: Optional[Any]
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    


class ObservedLookupError(ObservedException):
    ...


class ObservedIndexError(ObservedLookupError):
    ...


class ObservedKeyError(ObservedLookupError):
    ...


class ObservedGeneratorExit(ObservedException):
    ...


class ObservedAttributeError(ObservedException):
    ...


class ObservedRuntimeError(ObservedException):
    ...


class ObservedNotImplementedError(ObservedException):
    ...


class ObservedTypeError(ObservedException):
    ...


observed_exception_map = ...
def get_dynamo_observed_exception(exc_type: type[Exception]) -> type[ObservedException]:
    ...

def raise_observed_exception(exc_type: type[Exception], tx: InstructionTranslatorBase, *, args: Optional[list[Any]] = ..., kwargs: Optional[dict[str, Any]] = ...) -> NoReturn:
    ...

def handle_observed_exception(tx: Any) -> None:
    ...

exceptions_allowed_to_be_fallback = ...
def unimplemented_with_warning(e: Exception, code: types.CodeType, msg: str) -> NoReturn:
    ...

_NOTHING = ...
def unimplemented(msg: str, *, from_exc: Any = ..., case_name: Optional[str] = ...) -> NoReturn:
    ...

def unimplemented_v2_with_warning(e: Exception, code: types.CodeType, gb_type: str, context: str, explanation: str, hints: list[str]) -> NoReturn:
    ...

def format_graph_break_message(gb_type: str, context: str, explanation: str, hints: list[str]) -> str:
    ...

def get_gbid_documentation_link(gb_type: str) -> Optional[str]:
    """
    Retrieves the GBID documentation link for a given graph break type.

    Args:
        gb_type: The graph break type to look up.

    Returns:
        A string containing the documentation URL if found, otherwise None.
    """
    ...

def unimplemented_v2(gb_type: str, context: str, explanation: str, hints: list[str], *, from_exc: Any = ..., log_warning: bool = ...) -> NoReturn:
    """
    Called within dynamo to cause a graph break.
    Args:
        gb_type: Context-free graph break type. It should be a short string without any
                 information specific to the tracing context (i.e. no dynamically-generated strings)
        context: Developer context for the graph break. It can contain tracing context/dynamic strings.
        explanation: User-facing context-dependent explanation for the graph break. Can be dynamic.
        hints: List of user-facing hints for the graph break.
    """
    ...

def warning(msg: str) -> None:
    ...

class KeyErrorMsg:
    def __init__(self, value: Any) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


def augment_exc_message(exc: Exception, msg: str = ..., export: bool = ...) -> None:
    ...

def get_exc_message(e: Exception, compile_id: CompileId) -> tuple[Optional[str], Optional[int]]:
    ...

def get_stack_above_dynamo() -> StackSummary:
    ...

def get_real_stack(exc: Exception, frame: Optional[DynamoFrameType] = ...) -> Optional[StackSummary]:
    ...

def filter_stack(stack: StackSummary) -> StackSummary:
    ...

def remove_resume_prefix(name: str) -> Optional[str]:
    ...

def collapse_resume_frames(stack: StackSummary) -> StackSummary:
    """
    When we graph break, we create a resume function and make a regular Python call
    to it, which gets intercepted by Dynamo. This behavior is normally shown in the
    traceback, which can be confusing to a user. So we can filter out resume frames
    for better traceback clarity.

    Example:
    File "..." line 3, in f
        <line 3>
    File "..." line 5, in torch_dynamo_resume_in_f_at_80
        <line 5>
    File "..." line 10, in torch_dynamo_resume_in_f_at_120
        <line 10>

    becomes
    File "..." line 10, in f
        <line 10>
    """
    ...

def format_error_msg_verbose(exc: Exception, code: types.CodeType, record_filename: Optional[str] = ..., frame: Optional[DynamoFrameType] = ...) -> str:
    ...

def format_error_msg(exc: Exception, code: types.CodeType, record_filename: Optional[str] = ..., frame: Optional[DynamoFrameType] = ...) -> str:
    ...

