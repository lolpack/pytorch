"""
This type stub file was generated by pyright.
"""

import ast
import dataclasses
import enum
import functools
import pickle
import types
from typing import Any, Callable, NoReturn, Optional, TYPE_CHECKING, Union
from weakref import ReferenceType
from torch._guards import CompileId, Guard, GuardBuilderBase, Source
from torch.fx.experimental.symbolic_shapes import _CppShapeGuardsHelper, _ShapeGuardsHelper
from .types import DynamoFrameType, GuardFail, GuardFilterEntry, GuardFn
from torch._dynamo.output_graph import OutputGraphGuardsState

"""
Core guard system for Dynamo that detects when compiled code needs to be recompiled due to
changes in program state. Guards are conditions that must remain true for previously-compiled
code to be valid for reuse.

This module provides the infrastructure for creating, managing and checking guards, including:
- Guard creation and composition
- Guard state management and invalidation
- Guard checking and failure handling
- Utilities for guard optimization and debugging
- Integration with Dynamo's compilation caching

The guard system is critical for Dynamo's ability to efficiently reuse compiled code while
maintaining correctness by detecting when recompilation is necessary due to changes in
program state, tensor properties, or control flow.
"""
guard_manager_testing_hook_fn: Optional[Callable[[Any, Any], Any]] = ...
if TYPE_CHECKING:
    ...
log = ...
guards_log = ...
recompiles_log = ...
recompiles_verbose_log = ...
verbose_guards_log = ...
class GuardManagerWrapper:
    """
    A helper class that contains the root guard manager. An instance of this
    class is stored in the Dynamo cache entry, so that the cache entry can
    access the RootGuardManager stored in the "root" attribute and directly call
    the check_nopybind from C++.
    """
    def __init__(self, root=...) -> None:
        ...
    
    def collect_diff_guard_sources(self): # -> OrderedSet[str]:
        ...
    
    def finalize(self): # -> None:
        ...
    
    def populate_diff_guard_manager(self): # -> None:
        ...
    
    def clone_with_chosen_sources(self, chosen_sources): # -> RootGuardManager:
        ...
    
    def get_guard_lines(self, guard): # -> list[Any]:
        ...
    
    def get_manager_line(self, guard_manager, accessor_str=...):
        ...
    
    def construct_dict_manager_string(self, mgr, body): # -> None:
        ...
    
    def construct_manager_string(self, mgr, body): # -> None:
        ...
    
    def __str__(self) -> str:
        class IndentedBufferWithPrefix(IndentedBuffer):
            ...
        
        
    
    def check(self, x): # -> bool:
        ...
    
    def check_verbose(self, x): # -> GuardDebugInfo:
        ...
    
    def populate_code_parts_for_debugging(self): # -> None:
        ...
    


def from_numpy(a): # -> Tensor:
    ...

@functools.cache
def uninteresting_files(): # -> set[str]:
    ...

_CLOSURE_VARS: Optional[dict[str, object]] = ...
strip_function_call = ...
def get_verbose_code_part(code_part: str, guard: Guard) -> str:
    ...

def get_verbose_code_parts(code_parts: Union[str | list[str]], guard: Guard) -> list[str]:
    ...

def convert_int_to_concrete_values(dim) -> Optional[int]:
    ...

def convert_to_concrete_values(size_or_stride): # -> list[int | None]:
    ...

def get_tensor_guard_code_part(value, name, sizes, strides, pytype, dispatch_keys): # -> str:
    ...

def get_key_index(dct, key): # -> int:
    ...

def get_key_index_source(source, index): # -> str:
    ...

def raise_local_type_error(obj: Any) -> NoReturn:
    ...

@dataclasses.dataclass(frozen=True)
class NNModuleAttrAccessorInfo:
    present_in_generic_dict: bool = ...
    l1_key: Optional[str] = ...
    l2_key: Optional[str] = ...


def getitem_on_dict_manager(source, base_guard_manager, base_example_value, example_value, guard_manager_enum):
    ...

def match_on_id_for_tensor(guard): # -> bool:
    ...

@dataclasses.dataclass
class GuardCodeList:
    code_list: list[str]
    guard: Guard
    ...


class GuardManagerType(enum.Enum):
    GUARD_MANAGER = ...
    DICT_GUARD_MANAGER = ...


@functools.cache
def code_framelocals_names_reversed_cached(code: types.CodeType): # -> list[str]:
    ...

class GuardBuilder(GuardBuilderBase):
    def __init__(self, f_code: types.CodeType, id_ref: Callable[[Any, str], str], source_ref: Callable[[Source], str], lookup_weakrefs: Callable[[object], ReferenceType[object]], local_scope: dict[str, object], global_scope: dict[str, object], guard_manager: GuardManagerWrapper, check_fn_manager: CheckFunctionManager, serialization_mode: Optional[str] = ...) -> None:
        ...
    
    def guard_on_dict_keys_and_ignore_order(self, example_value, guard): # -> None:
        ...
    
    def guard_on_dict_keys_and_order(self, value, guard): # -> None:
        ...
    
    def getattr_on_nn_module(self, source, base_guard_manager, base_example_value, example_value, base_source_name, source_name, guard_manager_enum): # -> GuardManager:
        """
        This tries to avoid calling the expensive nn module custom getattr method by
        checking if the attribute is accessible via __dict__. For attributes that
        are not accessible via __dict__ (like descriptors), we fallback to
        PyObject_GetAttr.

        There are two cases that we optimize for
        1) attributes present directly in __dict__, e.g training.
        2) parameters/buffers/modules - they can be accessed via _parameters,
        _buffers, _modules keys in __dict__. For example, mod.linear can be
        accessed as mod.__dict__["_parameters"]["linear"]

        The most common and expensive case for nn module guards is of type
        mod.submod1.submod2.submod3.training. We avoid the python getattr of nn
        modules by going through the __dict__.
        """
        ...
    
    def requires_key_order_guarding(self, source): # -> bool:
        ...
    
    def get_guard_manager_type(self, source, example_value): # -> Literal[GuardManagerType.DICT_GUARD_MANAGER, GuardManagerType.GUARD_MANAGER]:
        ...
    
    def manager_guards_on_keys(self, mgr_enum):
        ...
    
    def get_global_guard_manager(self): # -> GuardManager:
        ...
    
    def get_guard_manager_from_source(self, source):
        ...
    
    def get_guard_manager(self, guard: Guard):
        ...
    
    def add_python_lambda_leaf_guard_to_root(self, code_parts, verbose_code_parts, closure_vars=..., is_epilogue=...): # -> None:
        ...
    
    def get(self, name: str, closure_vars: Optional[dict[str, Any]] = ...) -> Any:
        ...
    
    def arg_ref(self, guard: Union[str, Guard]) -> str:
        ...
    
    def HASATTR(self, guard: Guard): # -> GuardManager | None:
        ...
    
    def NOT_PRESENT_IN_GENERIC_DICT(self, guard: Guard, attr=...) -> None:
        ...
    
    def TYPE_MATCH(self, guard: Guard) -> None:
        ...
    
    def DICT_VERSION(self, guard: Guard): # -> None:
        ...
    
    def DICT_CONTAINS(self, guard: Guard, key: str, invert: bool): # -> None:
        ...
    
    def BOOL_MATCH(self, guard: Guard): # -> None:
        ...
    
    def NONE_MATCH(self, guard: Guard): # -> None:
        ...
    
    def ID_MATCH(self, guard: Guard): # -> None:
        ...
    
    def NOT_NONE_MATCH(self, guard: Guard, value=...): # -> None:
        ...
    
    def DISPATCH_KEY_SET_MATCH(self, guard: Guard): # -> None:
        ...
    
    def NAME_MATCH(self, guard: Guard): # -> None:
        ...
    
    def DUAL_LEVEL(self, guard: Guard): # -> None:
        ...
    
    def FUNCTORCH_STACK_MATCH(self, guard: Guard): # -> None:
        ...
    
    def AUTOGRAD_SAVED_TENSORS_HOOKS(self, guard: Guard): # -> None:
        ...
    
    def TENSOR_SUBCLASS_METADATA_MATCH(self, guard: Guard): # -> None:
        ...
    
    def EQUALS_MATCH(self, guard: Guard, recompile_hint: Optional[str] = ...): # -> None:
        ...
    
    def CONSTANT_MATCH(self, guard: Guard): # -> None:
        ...
    
    def NN_MODULE(self, guard: Guard): # -> None:
        ...
    
    def FUNCTION_MATCH(self, guard: Guard): # -> None:
        """things like torch.add and user defined functions"""
        ...
    
    def CLOSURE_MATCH(self, guard: Guard): # -> None:
        """matches a closure by __code__ id."""
        ...
    
    def BUILTIN_MATCH(self, guard: Guard): # -> None:
        ...
    
    def SEQUENCE_LENGTH(self, guard): # -> None:
        ...
    
    def TUPLE_ITERATOR_LEN(self, guard): # -> None:
        ...
    
    def RANGE_ITERATOR_MATCH(self, guard): # -> None:
        ...
    
    def DUPLICATE_INPUT(self, guard, source_b): # -> None:
        ...
    
    def WEAKREF_ALIVE(self, guard): # -> None:
        ...
    
    def MAPPING_KEYS_CHECK(self, guard): # -> None:
        """Guard on the key order of types.MappingProxyType object"""
        ...
    
    def DICT_KEYS_MATCH(self, guard): # -> None:
        """Insert guard to check that the keys of a dict are same"""
        ...
    
    def EMPTY_NN_MODULE_HOOKS_DICT(self, guard): # -> None:
        """Special guard to skip guards on empty hooks. This is controlled by skip_nnmodule_hook_guards"""
        ...
    
    def GRAD_MODE(self, guard: Guard): # -> None:
        ...
    
    def DETERMINISTIC_ALGORITHMS(self, guard: Guard): # -> None:
        ...
    
    def TORCH_FUNCTION_STATE(self, guard: Guard): # -> None:
        ...
    
    def FSDP_TRAINING_STATE(self, guard: Guard): # -> None:
        ...
    
    def DEFAULT_DEVICE(self, guard: Guard): # -> None:
        """Guard on CURRENT_DEVICE per torch.utils._device"""
        ...
    
    def SHAPE_ENV(self, guard: Guard): # -> None:
        ...
    
    def TENSOR_MATCH(self, guard: Guard, value=...): # -> None:
        ...
    


class PyExprCSEPass:
    USE_THRESHOLD = ...
    ALLOWED_NODE_TYPES = ...
    @dataclasses.dataclass
    class Config:
        expr_count: dict[str, int]
        expr_to_name: dict[str, str]
        ...
    
    
    class ExprCounter(ast.NodeVisitor):
        def __init__(self, config: PyExprCSEPass.Config) -> None:
            ...
        
        def visit(self, node: ast.AST) -> Any:
            ...
        
    
    
    class Replacer(ast.NodeTransformer):
        def __init__(self, config: PyExprCSEPass.Config, gen_name: Callable[[], str]) -> None:
            ...
        
        def visit(self, node: ast.AST) -> Any:
            ...
        
    
    
    def __init__(self) -> None:
        ...
    
    def count(self, exprs: list[str]) -> None:
        ...
    
    def replace(self, expr: str) -> tuple[list[str], str]:
        ...
    


def must_add_nn_module_guards(guard): # -> bool:
    ...

class DeletedGuardManagerWrapper(GuardManagerWrapper):
    def __init__(self, reason) -> None:
        ...
    
    def populate_diff_guard_manager(self): # -> None:
        ...
    


@dataclasses.dataclass
class ShapeCodeParts:
    python_code_parts: _ShapeGuardsHelper
    verbose_code_parts: _ShapeGuardsHelper
    cpp_code_parts: Optional[_CppShapeGuardsHelper]
    python_fallback: bool
    shape_env_sources: list[Source]
    ...


@dataclasses.dataclass
class GuardsState:
    output_graph: OutputGraphGuardsState
    shape_code_parts: Optional[ShapeCodeParts]
    ...


class GuardsStatePickler(pickle.Pickler):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def reducer_override(self, obj): # -> tuple[Callable[..., Any], tuple[Tensor, device, type[<subclass of Tensor and TensorWithFlatten>], int, object, list[Any]]] | tuple[Callable[..., Any], tuple[Tensor, device, type[Tensor], int]] | _NotImplementedType | tuple[Callable[..., Module], tuple[dict[str, Any]]] | tuple[Callable[..., ModuleType], tuple[str]] | tuple[Callable[..., DispatchKeySet], tuple[int]] | tuple[Callable[..., Any], tuple[Any]] | tuple[Any, tuple[Any]] | tuple[Callable[..., MappingProxyType[Any, Any]], tuple[dict[Any, Any]]]:
        ...
    


def pickle_guards_state(state: GuardsState) -> bytes:
    ...

class CheckFunctionManager:
    def __init__(self, f_code, output_graph=..., cache_entry=..., guard_fail_fn: Optional[Callable[[GuardFail], None]] = ..., guard_filter_fn: Optional[Callable[[list[GuardFilterEntry]], list[bool]]] = ..., guards_serialization_mode: Optional[str] = ..., shape_code_parts: Optional[ShapeCodeParts] = ...) -> None:
        ...
    
    def build_guards(self, sorted_guards, existing_diff_guard_sources, f_code, output_graph, serialization_mode=...): # -> tuple[GuardBuilder, GuardManagerWrapper]:
        ...
    
    def compile_check_fn(self, builder, guards_out, guard_fail_fn): # -> None:
        ...
    
    def invalidate(self, obj_str): # -> None:
        ...
    
    def id_ref(self, obj, obj_str): # -> int:
        """add a weakref, return the id"""
        ...
    
    def lookup_weakrefs(self, obj): # -> ReferenceType[object] | None:
        """Lookup the _weakrefs created in id_ref function for ID_MATCH'd objects"""
        ...
    


def build_guard_function(code_parts, closure_args) -> tuple[str, str]:
    ...

def is_recompiles_enabled():
    ...

def is_recompiles_verbose_enabled():
    ...

def make_torch_function_mode_stack_guard(initial_stack): # -> Callable[[], bool]:
    ...

def recompilation_reason_for_no_tensor_aliasing_guard(guard_manager, scope): # -> list[str]:
    ...

def strip_local_scope(s: str) -> str:
    """
    Replace occurrences of L[...] with just the inner content.
    Handles both single and double quotes.

    This is to generate user friendly recompilation messages.
    """
    ...

def get_guard_fail_reason_helper(guard_manager: GuardFn, f_locals: dict[str, object], compile_id: CompileId) -> str:
    """
    Return the reason why `guard_manager` failed.
    Updates `guard_failures` with the generated reason.
    Only the first failed check of guard_manager is reported.
    """
    ...

def get_guard_fail_reason(guard_manager: GuardFn, code: types.CodeType, f_locals: dict[str, object], compile_id: CompileId) -> str:
    ...

def get_and_maybe_log_recompilation_reasons(cache_entry, frame: DynamoFrameType) -> list[str]:
    """
    Return the list of guard failure reasons using cache_entry.
    Logs the recompilation reason if `recompiles` logging is enabled.
    Raises a RecompileError if `config.error_on_recompile` is enabled.
    """
    ...

def update_diff_guard_managers_for_existing_cache_entries(cache_entry): # -> set[Any]:
    ...

def guard_error_hook(guard_manager: GuardFn, code: types.CodeType, f_locals: dict[str, object], index: int, last: bool): # -> None:
    ...

def unique(seq): # -> Generator[Any, Any, None]:
    ...

def make_dupe_guard(obj_source, dupe_source): # -> partial[None] | None:
    ...

def install_guard(*guards, skip=...): # -> None:
    """
    Add dynamo guards to the current tracing context.

    Args:
        guards: guard(s) to add
        skip: number of stack frames to ignore for debug stack trace
    """
    ...

