"""
This type stub file was generated by pyright.
"""

import contextlib
import dataclasses
import functools
import sys
import types
import typing
from typing import Any, Callable, Optional, TYPE_CHECKING, Union
from torch.utils._functools import cache_method
from .bytecode_transformation import Instruction
from .output_graph import GraphCompileReason, OutputGraph
from .replay_record import ExecutionRecorder
from .source import Source
from .variables.base import VariableTracker
from .variables.builder import FrameStateSizeEntry
from .variables.constant import ConstantVariable
from .variables.ctx_manager import ContextWrappingVariable, GenericContextWrappingVariable
from .variables.functions import BaseUserFunctionVariable
from .variables.torch_function import SymbolicTorchFunctionState
from .package import CompilePackage

"""
Core module responsible for converting Python bytecode into TorchDynamo's symbolic execution format.

This module implements the bytecode-level tracing system that allows TorchDynamo to analyze
and transform Python code. It converts Python bytecode instructions into a symbolic format
that tracks the flow of tensors and other values through the program.

Key components:
- InstructionTranslatorBase: Base class for converting bytecode to symbolic execution
- InstructionTranslator: Main translator for function bytecode
- InliningInstructionTranslator: Handles inlining of called functions
- SpeculationLog: Manages state for speculative execution and rollback

The symbolic conversion process handles:
- Control flow (loops, conditionals, etc.)
- Function inlining and call stack management
- Tracking of program values and side effects
- Graph breaks and resumption points
- Exception handling and stack frame management

This is a core part of TorchDynamo's tracing system that enables ahead-of-time
optimization of PyTorch programs.
"""
if TYPE_CHECKING:
    ...
log = ...
graph_break_log = ...
trace_call_log = ...
trace_source_log = ...
trace_bytecode_log = ...
tls = ...
compare_op_handlers: dict[str, Any] = ...
handle_contains = ...
handle_not = ...
PT2_ISSUE_TRACKER_URL = ...
@dataclasses.dataclass
class SpeculationEntry:
    filename: str
    lineno: int
    instruction_pointer: int
    inst: Instruction
    _failed: bool = ...
    error_on_graph_break: Optional[bool] = ...
    reason: Optional[GraphCompileReason] = ...
    def fail_and_restart_analysis(self, error_on_graph_break: bool):
        """
        Start tracing of the current frame over again, and don't take this branch.
        """
        ...
    
    def failed(self, tx): # -> bool:
        ...
    


@dataclasses.dataclass
class SpeculationLog:
    """
    SpeculationLog replaces the prior copy_graphstate/restore_graphstate
    checkpointing.  Rather than saving/restoring state, we restart the
    dynamo conversion process over from the beginning -- but when we
    hit the start of the speculation that failed, we instead generate
    a graph break.
    """
    entries: list[SpeculationEntry] = ...
    index: int = ...
    def restart(self): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def next(self, filename: str, lineno: int, instruction_pointer, inst) -> SpeculationEntry:
        """
        Lookup or create a SpeculationEntry() that is shared across
        RestartAnalysis calls.  Args are used only for debug checks.
        """
        ...
    


@dataclasses.dataclass
class LocalState:
    automatic_dynamic: dict[str, FrameStateSizeEntry] = ...
    def render(self) -> str:
        ...
    


@dataclasses.dataclass
class DistributedState:
    compile_pg: Any
    local_state: LocalState
    all_states: Optional[list[LocalState]] = ...


class TensorifyState:
    force_specializations: set[str] = ...
    @classmethod
    def specialize(cls, index: str) -> None:
        ...
    
    @classmethod
    def should_specialize(cls, index: str) -> bool:
        ...
    
    @classmethod
    def clear(cls) -> None:
        ...
    
    @classmethod
    def empty(cls) -> bool:
        ...
    


@contextlib.contextmanager
def save_and_restart_speculation_log(tx: InstructionTranslatorBase): # -> Generator[None, Any, None]:
    ...

@contextlib.contextmanager
def temporarely_allow_writes_to_output_graph(tx: InstructionTranslatorBase): # -> Generator[None, Any, None]:
    ...

@dataclasses.dataclass
class BlockStackEntry:
    inst: Instruction
    target: Instruction
    stack_index: int
    with_context: Optional[Union[ContextWrappingVariable, GenericContextWrappingVariable]] = ...
    def can_restore(self): # -> bool:
        ...
    
    def resume_fn(self): # -> ReenterWith:
        ...
    
    def exit(self, tx, is_graph_break): # -> VariableTracker | None:
        ...
    


class SpeculationLogDivergence(AssertionError):
    ...


class ReturnValueOp(Exception):
    ...


class YieldValueOp(Exception):
    """
    Signal to the symbolic tracer to stop and return control flow to the
    caller
    """
    ...


def stack_op(fn: typing.Callable[..., object]): # -> _Wrapped[Callable[..., Any], object, Callable[..., Any], None]:
    ...

explain = ...
def log_graph_break(code_options, reason=..., exc_info=..., user_stack=...): # -> None:
    ...

def generic_jump(truth_fn: typing.Callable[[object], bool], push: bool): # -> Callable[..., None]:
    ...

def break_graph_if_unsupported(*, push): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    ...

class BytecodeDistpatchTableMeta(type):
    """Installs a `cls.dispatch_table` on every subclass to speed up calls to self.OPCODE()"""
    def __init__(cls, name, bases, dct) -> None:
        ...
    


@dataclasses.dataclass
class ExceptionStack:
    """
    Exception stack that it is shared among all InstructionTranslator instances
    """
    _exc_stack: list[VariableTracker] = ...
    _current_exception: Optional[VariableTracker] = ...
    def clear_current_exception(self): # -> None:
        ...
    
    def set_current_exception(self, val): # -> None:
        ...
    
    def move_current_exception_to_stack(self): # -> None:
        ...
    
    def get_current_exception(self): # -> VariableTracker:
        ...
    
    def pop(self): # -> VariableTracker:
        ...
    
    def append(self, val): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index):
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...


class InstructionTranslatorBase(metaclass=BytecodeDistpatchTableMeta):
    output: OutputGraph
    symbolic_locals: dict[str, VariableTracker]
    symbolic_globals: dict[str, VariableTracker]
    symbolic_torch_function_state: SymbolicTorchFunctionState
    stack: list[VariableTracker]
    instruction_pointer: Optional[int]
    current_instruction: Instruction
    block_stack: list[BlockStackEntry]
    lineno: int
    kw_names: Optional[ConstantVariable]
    accept_prefix_inst: bool
    prefix_insts: list[Instruction]
    inline_depth: int
    inconsistent_side_effects: bool
    current_speculation: Optional[SpeculationEntry]
    dispatch_table: list[Any]
    exn_vt_stack: ExceptionStack
    exec_recorder: Optional[ExecutionRecorder]
    strict_checks_fn: Optional[Callable[[VariableTracker], bool]]
    start_point: Optional[int]
    is_leaf_tracer: bool
    parent: Optional[InstructionTranslatorBase]
    debug_locals: list[tuple[VariableTracker, list[VariableTracker]]]
    package: Optional[CompilePackage]
    def mark_inconsistent_side_effects(self): # -> None:
        """
        InstructionTranslator has encountered instructions which may cause
        dynamo to see a different version of history from eager
        See: https://github.com/pytorch/pytorch/issues/110765
        """
        ...
    
    def maybe_has_backedge(self): # -> bool:
        ...
    
    def cellvars(self): # -> tuple[Any, ...]:
        ...
    
    def freevars(self): # -> tuple[Any, ...]:
        ...
    
    def cell_and_freevars(self): # -> tuple[Any, ...]:
        ...
    
    def prune_dead_locals(self): # -> None:
        ...
    
    def call_function(self, fn: VariableTracker, args: list[VariableTracker], kwargs: dict[str, VariableTracker]): # -> None:
        ...
    
    def inline_generator_function(self, fn, args, kwargs): # -> VariableTracker:
        """
        Redirect the call to the generator "call_function"
        """
        ...
    
    def inline_user_function_return(self, fn, args, kwargs): # -> VariableTracker | ListIteratorVariable:
        """
        A call to some user defined function by inlining it.
        """
        ...
    
    def get_line_of_code_header(self, lineno=...): # -> str:
        ...
    
    def get_log_starts_line_log_str(self): # -> str:
        ...
    
    def starts_line(self, lineno): # -> None:
        ...
    
    def step(self): # -> bool | None:
        """Process exactly one instruction, return False we should exit"""
        ...
    
    if sys.version_info >= (3, 11):
        def update_block_stack(self, inst): # -> None:
            ...
        
    else:
        ...
    @property
    def next_instruction(self):
        ...
    
    def step_graph_break(self, continue_inst): # -> None:
        ...
    
    def run_ctx_mgr(self): # -> _GeneratorContextManager[None, None, None]:
        ...
    
    def run(self): # -> None:
        ...
    
    def push(self, val: Optional[VariableTracker]): # -> None:
        ...
    
    def push_many(self, vals: list[VariableTracker]): # -> None:
        ...
    
    def pop(self) -> VariableTracker:
        ...
    
    def popn(self, n: int) -> list[VariableTracker]:
        ...
    
    def LOAD_FAST(self, inst): # -> None:
        ...
    
    def LOAD_DEREF(self, inst): # -> None:
        ...
    
    def STORE_FAST(self, inst): # -> None:
        ...
    
    def DELETE_FAST(self, inst): # -> None:
        ...
    
    def STORE_DEREF(self, inst): # -> None:
        ...
    
    LOAD_CLOSURE = ...
    def LOAD_CONST(self, inst): # -> None:
        ...
    
    @functools.cached_property
    def nn_modules_globals_vt(self): # -> Any:
        ...
    
    def LOAD_GLOBAL(self, inst): # -> None:
        ...
    
    def STORE_GLOBAL(self, inst): # -> None:
        ...
    
    @cache_method
    def import_source(self, module_name): # -> GlobalSource:
        """Create an alias to a module for use in guards"""
        ...
    
    def resolve_name(self, name, package, level): # -> str:
        """
        Copied from the Cpython implementation of __import__
        Resolve a relative module name to an absolute one.
        https://github.com/python/cpython/blob/5a094f0255eea1db58fb2cf14c200971e64ec36e/Lib/importlib/_bootstrap.py#L902
        """
        ...
    
    def calc_package(self): # -> Any:
        """
        Copied from the Cpython implementation of __import__
        https://github.com/python/cpython/blob/5a094f0255eea1db58fb2cf14c200971e64ec36e/Lib/importlib/_bootstrap.py#L1090
        """
        ...
    
    def IMPORT_NAME(self, inst): # -> None:
        ...
    
    EAGER_IMPORT_NAME = ...
    def IMPORT_FROM(self, inst): # -> None:
        ...
    
    @cache_method
    def load_builtin_from_argval(self, argval): # -> Any | VariableTracker:
        ...
    
    def load_builtin(self, inst): # -> None:
        ...
    
    def jump(self, inst): # -> None:
        ...
    
    JUMP_FORWARD = ...
    JUMP_ABSOLUTE = ...
    POP_JUMP_IF_FALSE = ...
    POP_JUMP_IF_TRUE = ...
    JUMP_IF_FALSE_OR_POP = ...
    JUMP_IF_TRUE_OR_POP = ...
    def SETUP_LOOP(self, inst): # -> None:
        ...
    
    def SETUP_EXCEPT(self, inst): # -> None:
        ...
    
    def POP_BLOCK(self, inst): # -> None:
        ...
    
    def SETUP_WITH(self, inst): # -> None:
        ...
    
    def SETUP_FINALLY(self, inst): # -> None:
        ...
    
    def BEGIN_FINALLY(self, inst): # -> None:
        ...
    
    def WITH_CLEANUP_START(self, inst): # -> None:
        ...
    
    def WITH_CLEANUP_FINISH(self, inst): # -> None:
        ...
    
    def FOR_ITER(self, inst): # -> None:
        ...
    
    def RAISE_VARARGS(self, inst):
        ...
    
    def CLEANUP_THROW(self, inst):
        ...
    
    def RERAISE(self, inst):
        ...
    
    def WITH_EXCEPT_START(self, inst): # -> None:
        ...
    
    def exception_handler(self, raised_exception): # -> None:
        ...
    
    def PUSH_EXC_INFO(self, inst): # -> None:
        ...
    
    def POP_EXCEPT(self, inst): # -> None:
        ...
    
    def check_if_exc_matches(self): # -> bool:
        ...
    
    def CHECK_EXC_MATCH(self, inst): # -> None:
        ...
    
    def JUMP_IF_NOT_EXC_MATCH(self, inst): # -> None:
        ...
    
    def COMPARE_OP(self, inst): # -> None:
        ...
    
    def GET_ITER(self, inst): # -> None:
        ...
    
    @break_graph_if_unsupported(push=1)
    def CALL_FUNCTION(self, inst): # -> None:
        ...
    
    @break_graph_if_unsupported(push=1)
    def CALL_FUNCTION_EX(self, inst): # -> None:
        ...
    
    @break_graph_if_unsupported(push=1)
    def CALL_FUNCTION_KW(self, inst): # -> None:
        ...
    
    def LOAD_METHOD_SUPER(self, inst): # -> None:
        ...
    
    def LOAD_ATTR_SUPER(self, inst): # -> None:
        ...
    
    def LOAD_METHOD(self, inst): # -> None:
        ...
    
    def CALL_METHOD(self, inst): # -> None:
        ...
    
    def LOAD_ATTR(self, inst): # -> None:
        ...
    
    def STORE_ATTR(self, inst): # -> None:
        ...
    
    def store_attr_graph_break(self, inst):
        ...
    
    def DELETE_ATTR(self, inst): # -> None:
        ...
    
    def create_call_resume_at(self, offset, all_stack_locals_metadata):
        ...
    
    def should_compile_partial_graph(self) -> bool:
        ...
    
    @break_graph_if_unsupported(push=0)
    def STORE_SUBSCR(self, inst): # -> None:
        ...
    
    def DELETE_SUBSCR(self, inst): # -> None:
        ...
    
    def BUILD_TUPLE(self, inst): # -> None:
        ...
    
    def BUILD_SLICE(self, inst): # -> None:
        ...
    
    def BUILD_LIST(self, inst): # -> None:
        ...
    
    def BUILD_SET(self, inst): # -> None:
        ...
    
    def BUILD_LIST_UNPACK(self, inst, cls=...): # -> None:
        ...
    
    def BUILD_TUPLE_UNPACK(self, inst): # -> None:
        ...
    
    BUILD_TUPLE_UNPACK_WITH_CALL = ...
    def BUILD_MAP(self, inst): # -> None:
        ...
    
    def BUILD_MAP_UNPACK(self, inst): # -> None:
        ...
    
    BUILD_MAP_UNPACK_WITH_CALL = ...
    def BUILD_CONST_KEY_MAP(self, inst): # -> None:
        ...
    
    def MAP_ADD(self, inst): # -> None:
        ...
    
    def SET_ADD(self, inst): # -> VariableTracker:
        ...
    
    def SET_UPDATE(self, inst): # -> None:
        ...
    
    def LIST_APPEND(self, inst): # -> None:
        ...
    
    def MAKE_FUNCTION(self, inst): # -> None:
        ...
    
    def UNPACK_SEQUENCE(self, inst): # -> None:
        ...
    
    def UNPACK_EX(self, inst): # -> None:
        ...
    
    def NOP(self, inst): # -> None:
        ...
    
    def POP_TOP(self, inst): # -> None:
        ...
    
    def ROT_TWO(self, inst): # -> None:
        ...
    
    def ROT_THREE(self, inst): # -> None:
        ...
    
    def ROT_FOUR(self, inst): # -> None:
        ...
    
    def DUP_TOP(self, inst): # -> None:
        ...
    
    def DUP_TOP_TWO(self, inst): # -> None:
        ...
    
    def FORMAT_VALUE(self, inst): # -> None:
        ...
    
    def BUILD_STRING(self, inst): # -> None:
        ...
    
    def IS_OP(self, inst): # -> None:
        ...
    
    def CONTAINS_OP(self, inst): # -> None:
        ...
    
    def LIST_EXTEND(self, inst): # -> None:
        ...
    
    def LIST_TO_TUPLE(self, inst): # -> None:
        ...
    
    def STOPITERATION_ERROR(self, inst): # -> None:
        ...
    
    def DICT_MERGE(self, inst): # -> None:
        ...
    
    DICT_UPDATE = ...
    def GEN_START(self, inst): # -> None:
        ...
    
    def GET_LEN(self, inst): # -> None:
        ...
    
    def MATCH_MAPPING(self, inst): # -> None:
        ...
    
    def MATCH_SEQUENCE(self, inst): # -> None:
        ...
    
    def MATCH_KEYS(self, inst): # -> None:
        ...
    
    def LOAD_ASSERTION_ERROR(self, inst): # -> None:
        ...
    
    def LOAD_BUILD_CLASS(self, inst):
        ...
    
    UNARY_POSITIVE = ...
    UNARY_NEGATIVE = ...
    UNARY_NOT = ...
    UNARY_INVERT = ...
    BINARY_POWER = ...
    BINARY_MULTIPLY = ...
    BINARY_MATRIX_MULTIPLY = ...
    BINARY_FLOOR_DIVIDE = ...
    BINARY_TRUE_DIVIDE = ...
    BINARY_MODULO = ...
    BINARY_REMAINDER = ...
    BINARY_ADD = ...
    BINARY_SUBTRACT = ...
    BINARY_SUBSCR = ...
    BINARY_LSHIFT = ...
    BINARY_RSHIFT = ...
    BINARY_AND = ...
    BINARY_OR = ...
    BINARY_XOR = ...
    INPLACE_POWER = ...
    INPLACE_MULTIPLY = ...
    INPLACE_MATRIX_MULTIPLY = ...
    INPLACE_FLOOR_DIVIDE = ...
    INPLACE_TRUE_DIVIDE = ...
    INPLACE_MODULO = ...
    INPLACE_REMAINDER = ...
    INPLACE_ADD = ...
    INPLACE_SUBTRACT = ...
    INPLACE_LSHIFT = ...
    INPLACE_RSHIFT = ...
    INPLACE_AND = ...
    INPLACE_XOR = ...
    INPLACE_OR = ...
    def RESUME(self, inst): # -> None:
        ...
    
    if sys.version_info >= (3, 11):
        def BINARY_OP(self, inst): # -> Any:
            ...
        
    def PRECALL(self, inst): # -> None:
        ...
    
    def KW_NAMES(self, inst): # -> None:
        ...
    
    def PUSH_NULL(self, inst): # -> None:
        ...
    
    @break_graph_if_unsupported(push=1)
    def CALL(self, inst): # -> None:
        ...
    
    def COPY(self, inst): # -> None:
        ...
    
    def SWAP(self, inst): # -> None:
        ...
    
    JUMP_BACKWARD = ...
    JUMP_BACKWARD_NO_INTERRUPT = ...
    POP_JUMP_FORWARD_IF_TRUE = ...
    POP_JUMP_BACKWARD_IF_TRUE = ...
    POP_JUMP_FORWARD_IF_FALSE = ...
    POP_JUMP_BACKWARD_IF_FALSE = ...
    def CACHE(self, inst): # -> None:
        ...
    
    def BEFORE_WITH(self, inst): # -> None:
        ...
    
    def setup_or_before_with(self, inst): # -> None:
        ...
    
    def append_prefix_inst(self, inst): # -> None:
        ...
    
    def MAKE_CELL(self, inst): # -> None:
        ...
    
    def COPY_FREE_VARS(self, inst): # -> None:
        ...
    
    def RETURN_GENERATOR(self, inst): # -> None:
        ...
    
    def END_FOR(self, inst): # -> None:
        ...
    
    def LOAD_FAST_CHECK(self, inst): # -> None:
        ...
    
    def LOAD_FAST_AND_CLEAR(self, inst): # -> None:
        ...
    
    def LOAD_SUPER_ATTR(self, inst): # -> None:
        ...
    
    def CALL_INTRINSIC_1(self, inst): # -> None:
        ...
    
    def END_SEND(self, inst): # -> None:
        ...
    
    @break_graph_if_unsupported(push=1)
    def CALL_KW(self, inst): # -> None:
        ...
    
    def TO_BOOL(self, inst): # -> None:
        ...
    
    def SET_FUNCTION_ATTRIBUTE(self, inst): # -> None:
        ...
    
    def CONVERT_VALUE(self, inst): # -> None:
        ...
    
    def FORMAT_SIMPLE(self, inst): # -> None:
        ...
    
    def FORMAT_WITH_SPEC(self, inst): # -> None:
        ...
    
    def is_non_empty_graph(self): # -> bool:
        ...
    
    def format_frame_summary(self, additional_stack_frames=...): # -> str:
        ...
    
    def frame_summary(self): # -> FrameSummary:
        ...
    
    def is_co_filename_from_nn_modules(self): # -> bool:
        ...
    
    def store_global_weakref_by_id(self, prefix, value): # -> str:
        ...
    
    @property
    def fake_mode(self): # -> Any:
        ...
    
    @contextlib.contextmanager
    def strict_translation_mode(self, check_fn: Callable[[VariableTracker], bool]): # -> Generator[None, Any, None]:
        """
        Strict mode is enabled on a per-VariableTracker level depending on the return value of check_fn(node).
        """
        ...
    
    def speculate(self) -> SpeculationEntry:
        ...
    
    def __init__(self, output: OutputGraph, instructions: list[Instruction], f_locals: dict[str, Any], f_globals: dict[str, Any], f_builtins: dict[str, Any], code_options: dict[str, Any], symbolic_locals: dict[str, VariableTracker], symbolic_globals: dict[str, VariableTracker], symbolic_torch_function_state: SymbolicTorchFunctionState, f_code: types.CodeType, export: bool, inline_depth: int, speculation_log: SpeculationLog, exn_vt_stack: ExceptionStack, distributed_state: Optional[DistributedState], closure: Optional[tuple[types.CellType]] = ..., package: Optional[CompilePackage] = ...) -> None:
        ...
    


class InstructionTranslator(InstructionTranslatorBase):
    @staticmethod
    def current_tx() -> InstructionTranslator:
        ...
    
    @contextlib.contextmanager
    def set_current_tx(self): # -> Generator[None, Any, None]:
        ...
    
    def __init__(self, instructions: list[Instruction], f_code, f_locals, f_globals, f_builtins, closure, torch_function_mode_stack, code_options, compiler_fn, one_graph, export, export_constraints, frame_state, speculation_log: SpeculationLog, exn_vt_stack: ExceptionStack, distributed_state: Optional[DistributedState], package: Optional[CompilePackage]) -> None:
        ...
    
    def get_example_value(self, source: Source): # -> Any:
        ...
    
    def run(self): # -> None:
        ...
    
    def should_compile_partial_graph(self): # -> bool:
        ...
    
    def create_call_resume_at(self, inst, all_stack_locals_metadata): # -> list[DataclassInstance]:
        ...
    
    def symbolic_locals_contain_module_class(self): # -> bool:
        ...
    
    def replace_tos_if_return_is_generator(self): # -> None:
        ...
    
    def RETURN_VALUE(self, inst):
        ...
    
    def RETURN_CONST(self, inst):
        ...
    


if sys.version_info >= (3, 11):
    _binary_op_lookup = ...
class InliningInstructionTranslator(InstructionTranslatorBase):
    """Trace and inline a called method"""
    symbolic_result: Optional[VariableTracker]
    parent: InstructionTranslatorBase
    @classmethod
    def inline_call(cls, parent, func, args, kwargs): # -> VariableTracker | ListIteratorVariable:
        ...
    
    @staticmethod
    def check_inlineable(func): # -> SkipResult:
        ...
    
    @staticmethod
    def build_inline_tracer(parent, func: VariableTracker, args: list[VariableTracker], kwargs): # -> InliningGeneratorInstructionTranslator | InliningInstructionTranslator:
        ...
    
    def inline_call_(self): # -> VariableTracker | ListIteratorVariable:
        ...
    
    def __init__(self, parent: InstructionTranslatorBase, code: types.CodeType, symbolic_locals: dict[str, VariableTracker], symbolic_globals: dict[str, VariableTracker], symbolic_torch_function_state: SymbolicTorchFunctionState, funcvar: BaseUserFunctionVariable) -> None:
        ...
    
    @property
    def fake_mode(self): # -> Any:
        ...
    
    def run_ctx_mgr(self): # -> _GeneratorContextManager[None, None, None]:
        ...
    
    def should_compile_partial_graph(self): # -> Literal[False]:
        ...
    
    def create_call_resume_at(self, inst, all_stack_locals_metadata):
        ...
    
    def RETURN_VALUE(self, inst):
        ...
    
    def RETURN_CONST(self, inst):
        ...
    
    def get_globals_source_and_value(self, name): # -> tuple[Any | ModuleType | dict[str, Any], Any, AttrSource | DictGetItemSource]:
        ...
    
    def STORE_GLOBAL(self, inst): # -> None:
        ...
    


class InliningGeneratorInstructionTranslator(InliningInstructionTranslator):
    generated_items: list[VariableTracker]
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def YIELD_VALUE(self, inst: Instruction): # -> None:
        ...
    
    def GET_YIELD_FROM_ITER(self, inst): # -> None:
        ...
    
    def RETURN_VALUE(self, inst):
        ...
    
    def RETURN_CONST(self, inst):
        ...
    
    def YIELD_FROM(self, inst): # -> None:
        ...
    
    def SEND(self, inst): # -> None:
        ...
    


