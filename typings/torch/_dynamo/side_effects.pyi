"""
This type stub file was generated by pyright.
"""

import contextlib
from types import CellType
from typing import Any, Optional, TYPE_CHECKING
from .codegen import PyCodegen
from .source import Source
from .variables.base import VariableTracker
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
Side effect tracking and management for TorchDynamo's compilation system.

This module provides infrastructure for tracking and managing side effects that occur
during symbolic execution, including:

- Tracking mutations to objects, attributes, and variables
- Managing context changes (cell variables, global namespace modifications)
- Handling aliasing and object identity preservation
- Managing stack frame state and local variable changes
- Tracking function calls with side effects

Key classes:
- SideEffects: Main container for tracking all side effects during execution
- MutableSideEffects: Specialization for mutable object tracking
- AttributeMutation/ValueMutation: Track specific types of mutations
- Various specialized side effect classes for different scenarios

The side effect system ensures that mutations performed during symbolic execution
are properly replayed during runtime, maintaining the correctness of compiled code
while enabling optimizations where safe.
"""
if TYPE_CHECKING:
    ...
class SideEffects:
    """
    Maintain records of mutations and provide methods to apply them during code generation.

    Handles tracking and applying side effects during PyTorch Dynamo compilation,
    maintaining Python semantics by managing mutations, attribute modifications,
    and other side effects that occur during program execution.

    Key responsibilities:
    - Tracks mutations to Python objects, lists, and dictionaries that need to be
    applied after an FX graph is run.
    - Manages attribute modifications and deletions
    - Handles tensor hooks and backward pass state
    - Tracks cell variable mutations and global variable changes
    - Ensures correct ordering and application of side effects after graph execution

    This ensures that optimized code behaves identically to the original Python code with
    respect to object mutations and other side effects.
    """
    id_to_variable: dict[int, VariableTracker]
    store_attr_mutations: dict[VariableTracker, dict[str, VariableTracker]]
    keepalive: list[Any]
    def __init__(self, output_graph, id_to_variable=..., store_attr_mutations=..., keepalive=..., save_for_backward=..., tensor_hooks=...) -> None:
        ...
    
    def ignore_mutations_on(self, var): # -> None:
        """Mutations to this variable will be executed but not not tracked,
        typically used for temporary mutations that are later restored."""
        ...
    
    def stop_ignoring_mutations_on(self, var): # -> None:
        """Remove a variable from the skip mutation set, restoring normal mutation tracking."""
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def diff(self, other: SideEffects) -> Optional[str]:
        ...
    
    def clone(self): # -> Self:
        """Create a shallow copy"""
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __getitem__(self, item): # -> VariableTracker:
        ...
    
    def should_allow_side_effects_under_checkpoint(self): # -> None:
        ...
    
    def should_allow_externally_visible_side_effects_in_subtracer(self): # -> None:
        ...
    
    def is_reconstructing_generator(self): # -> None:
        ...
    
    def check_allowed_side_effect(self, item: VariableTracker): # -> Literal[True] | None:
        ...
    
    def store_attr(self, item: VariableTracker, name: str, value: VariableTracker): # -> None:
        ...
    
    def load_attr(self, item, name, deleted_ok=..., check=...): # -> VariableTracker:
        ...
    
    def store_cell(self, cellvar, value): # -> None:
        ...
    
    def load_cell(self, cellvar): # -> VariableTracker:
        ...
    
    def load_global(self, gvar: VariableTracker, name: str): # -> VariableTracker:
        ...
    
    def store_global(self, gvar: VariableTracker, name: str, value: VariableTracker): # -> None:
        ...
    
    @staticmethod
    def cls_supports_mutation_side_effects(cls): # -> bool:
        ...
    
    def is_attribute_mutation(self, item): # -> bool:
        ...
    
    def has_pending_mutation(self, item): # -> bool:
        ...
    
    def has_pending_mutation_of_attr(self, item, name): # -> bool:
        ...
    
    def is_modified(self, item): # -> bool:
        ...
    
    track_mutable = ...
    def track_object_existing(self, item: Any, variable: VariableTracker): # -> VariableTracker:
        ...
    
    def track_object_new(self, cls_source: Source, user_cls: Any, variable_cls: Any, options): # -> Any:
        ...
    
    def get_variable_cls(self, user_cls): # -> type[TorchFunctionModeVariable] | type[GenericContextWrappingVariable] | type[UnspecializedNNModuleVariable] | type[UserDefinedDictVariable] | type[UserDefinedTupleVariable] | type[UserDefinedListVariable] | type[MutableMappingVariable] | type[FrozenDataClassVariable] | type[UserDefinedExceptionObjectVariable] | type[UserDefinedObjectVariable]:
        ...
    
    def get_example_value(self, base_cls_vt, cls_vt, init_args): # -> Module:
        ...
    
    def track_new_user_defined_object(self, base_cls_vt, cls_vt, init_args): # -> FrozenDataClassVariable | GenericContextWrappingVariable | MutableMappingVariable | TorchFunctionModeVariable | UnspecializedNNModuleVariable | UserDefinedDictVariable | UserDefinedExceptionObjectVariable | UserDefinedListVariable | UserDefinedObjectVariable | UserDefinedTupleVariable:
        """
        Creates a UserDefinedObjectVariable (or its subclass) variable tracker
        and mark it for attribute mutation tracking.

        Also records the variable trackers to call __new__ method on
        reconstruction. Roughly, the reconstruction looks like this
            base_cls_vt.__new__(user_cls, *init_args)
        """
        ...
    
    def track_cell_new(self): # -> CellVariable:
        ...
    
    def track_cell_existing(self, source: Optional[Source], cell: CellType, contents: VariableTracker): # -> CellVariable:
        ...
    
    def track_global_existing(self, source: Source, item: Any): # -> NewGlobalVariable:
        ...
    
    def track_save_for_backward(self, ctx, args): # -> None:
        ...
    
    def track_tensor_variables_from_runahead_side_effects(self, other): # -> None:
        ...
    
    def prune_dead_object_new(self, tx): # -> None:
        ...
    
    def mutation(self, var): # -> None:
        ...
    
    def has_existing_dict_mutation(self): # -> bool:
        ...
    
    def codegen_save_tempvars(self, cg: PyCodegen): # -> None:
        ...
    
    def register_hook(self, tensor, hook, handle, name): # -> None:
        ...
    
    def remove_hook(self, idx): # -> None:
        ...
    
    def codegen_hooks(self, cg): # -> None:
        ...
    
    def get_ca_final_callbacks_var(self): # -> ListVariable:
        ...
    
    def codegen_update_mutated(self, cg: PyCodegen): # -> None:
        ...
    
    def is_empty(self): # -> bool:
        ...
    
    def clear(self): # -> None:
        ...
    


@contextlib.contextmanager
def allow_side_effects_under_checkpoint(tx: InstructionTranslator): # -> Generator[None, Any, None]:
    ...

@contextlib.contextmanager
def allow_externally_visible_side_effects_in_subtracer(tx: InstructionTranslator): # -> Generator[None, Any, None]:
    ...

@contextlib.contextmanager
def disallow_side_effects_in_generator(tx: InstructionTranslator): # -> Generator[None, Any, None]:
    ...

