"""
This type stub file was generated by pyright.
"""

import torch.fx as fx
import torch.nn as nn
from typing import Any, Callable, TYPE_CHECKING, Union
from torch._inductor.compile_fx import _CompileFxCallable

"""
Utilities for reproducing and debugging issues in PyTorch's Dynamo AOT compilation.

This module provides tools and infrastructure for:
1. Generating minimal reproducible test cases ("repros") from failing compilations
2. Analyzing accuracy issues between eager and compiled execution
3. Minifying large models/inputs to isolate problematic patterns
4. Debugging compiler errors and accuracy divergences

The main components include:
- Repro generation: Creates standalone Python files that reproduce compiler issues
- Minification: Reduces large graphs to minimal failing examples
- Accuracy analysis: Compares compiled vs eager execution, with fp64 reference
- Debug tools: Dumps graph state, tracks intermediates, analyzes divergences

This is primarily used by PyTorch developers and researchers to debug issues in
the Dynamo AOT compilation pipeline, particularly for the Inductor backend.
"""
if TYPE_CHECKING:
    ...
log = ...
inductor_config = ...
use_buck = ...
def wrap_compiler_debug(unconfigured_compiler_fn: _CompileFxCallable, compiler_name: str) -> _CompileFxCallable:
    """
    Minifier for Fx Graph modules after Aot Autograd has finished. We wrap both
    forward and backward call separately with the backend compiler_fn - like
    inductor or nvfuser. Intercepting after Aot Autograd presents neat
    abstraction, where all the params are lifted as graph inputs, making it easy
    to save the graph as a string.
    """
    ...

def maybe_fbcode_instructions(): # -> str:
    ...

def generate_compiler_repro_string(gm, args, *, stable_output=..., save_dir=..., stable_hash=...): # -> str:
    ...

def save_graph_repro(fd, gm, args, compiler_name, *, stable_output=..., save_dir=..., command=..., accuracy=..., tracing_mode=..., check_str=..., stable_hash=...): # -> None:
    ...

def dump_compiler_graph_state(gm, args, compiler_name, *, accuracy=...): # -> None:
    ...

def dump_to_minify(gm, args, compiler_name: str): # -> None:
    ...

def isolate_fails(fx_g, args, compiler_name: str, env=..., save_dir=..., accuracy=..., tracing_mode=..., check_str=...): # -> bool | Any:
    ...

def inductor_fails(fx_g, args, check_str=...): # -> bool:
    ...

def inductor_accuracy_fails(fx_g, args, check_str=..., *, require_fp64=..., ignore_non_fp=...): # -> bool:
    ...

backend_aot_accuracy_fails = ...
def repro_common(options, mod, load_args): # -> tuple[GraphModule, list[Any]]:
    ...

ACCURACY_FAILS: dict[str, Callable[[nn.Module, Any], bool]] = ...
def repro_minifier_query(options, mod, load_args):
    ...

def repro_minify(options, mod, load_args): # -> None:
    ...

def repro_analyze(options, mod, load_args): # -> None:
    class WriterInterp(fx.Interpreter):
        ...
    
    
    class ExactReaderInterp(fx.Interpreter):
        ...
    
    
    class ReaderInterp(fx.Interpreter):
        ...
    
    

def repro_get_args(options, mod, load_args): # -> tuple[GraphModule, list[Any]]:
    ...

def repro_run(options, mod, load_args): # -> None:
    ...

def run_repro(mod, load_args, *, command=..., accuracy: Union[bool, str] = ..., save_dir=..., tracing_mode=..., patch_code=..., check_str=..., **kwargs):
    ...

