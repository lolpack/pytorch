"""
This type stub file was generated by pyright.
"""

import functools
import typing
import numpy as np
from dataclasses import dataclass
from types import CodeType, FunctionType, ModuleType
from typing import Any, Callable, Optional, TypeVar, Union
from typing_extensions import ParamSpec
from torch._C._dynamo.guards import GlobalStateGuard
from torch.fx.graph_module import _forward_from_src as original_forward_from_src
from .eval_frame import TorchPatcher
from .hooks import Hooks
from .types import BytecodeHook, CacheEntry, ConvertFrameReturn, DynamoFrameType
from .backends.registry import CompilerFn
from .package import CompilePackage
from .variables.builder import FrameStateSizeEntry
from torch.utils.hooks import RemovableHandle

"""
This module implements TorchDynamo's core frame conversion functionality, transforming Python
frames into FX graphs. It handles:

- Frame analysis and bytecode transformation
- Guard creation and management for dynamic behaviors
- Cache management for recompilation
- Error handling and fallback mechanisms

Key classes:
- ConvertFrame: Main entry point for frame conversion with error handling
- ConvertFrameAssert: Implements core frame to graph conversion logic
- Tracker: Tracks input/output code objects during conversion
- CatchErrorsWrapper: Provides error handling and suppression logic

The conversion process preserves program semantics while enabling optimizations
through torch.compile() and related systems.
"""
np: Optional[ModuleType]
if typing.TYPE_CHECKING:
    ...
log = ...
bytecode_log = ...
graph_break_log = ...
compile_lock = ...
_T = TypeVar("_T")
_P = ParamSpec("_P")
class TODO_UNKNOWN:
    ...


class Tracker:
    def __init__(self) -> None:
        ...
    
    def add(self, strong_obj: CodeType) -> None:
        ...
    
    def __contains__(self, item: CodeType) -> bool:
        ...
    
    def clear(self) -> None:
        ...
    


input_codes = ...
output_codes = ...
initial_global_state: Optional[GlobalStateGuard] = ...
@functools.wraps(original_forward_from_src)
def fx_forward_from_src_skip_result(src: str, globals: dict[str, Any], co_fields: Optional[dict[str, str]] = ...) -> FunctionType:
    ...

def preserve_global_state(fn: Callable[_P, _T]) -> Callable[_P, _T]:
    """
    Context manager to:
        1) Save/restore torch.is_grad_enabled() state
        2) Save/restore python random state
        3) Save/restore torch random state
        4) Monkey patch torch.fx.graph_module._forward_from_src
    """
    ...

@TorchPatcher.suppress_torch_distributed_warnings
def has_tensor_in_frame(frame: DynamoFrameType) -> bool:
    """Check if the frame has torch.* related bits"""
    ...

def exception_handler(e: Exception, code: CodeType, frame: Optional[DynamoFrameType] = ..., export: bool = ...) -> None:
    ...

FRAME_COUNTER = ...
FRAME_COMPILE_COUNTER: typing.Counter[Union[int, FrameStateSizeEntry]] = ...
def maybe_cprofile(func: Callable[_P, _T]) -> Callable[_P, _T]:
    ...

def cprofile_wrapper(func: Callable[_P, _T]) -> Callable[_P, _T]:
    ...

@dataclass
class ConvertFrameBox:
    error_on_graph_break: Optional[bool] = ...


class ConvertFrameAssert:
    def __init__(self, compiler_fn: CompilerFn, one_graph: bool = ..., export: bool = ..., export_constraints: Optional[typing.Never] = ..., package: Optional[CompilePackage] = ...) -> None:
        ...
    
    def __call__(self, frame: DynamoFrameType, cache_entry: Optional[CacheEntry], hooks: Hooks, frame_state: dict[str, Union[int, FrameStateSizeEntry]], *, skip: int = ...) -> ConvertFrameReturn:
        ...
    


def convert_frame_assert(compiler_fn: CompilerFn, one_graph: bool = ..., export: bool = ..., export_constraints: Optional[typing.Never] = ..., package: Optional[CompilePackage] = ...) -> ConvertFrameAssert:
    """Fully convert a frame into an FX graph, raising an exception if we fail."""
    ...

if typing.TYPE_CHECKING:
    ...
_bytecode_hooks: dict[int, BytecodeHook] = ...
def register_bytecode_hook(hook: BytecodeHook) -> RemovableHandle:
    """Register hooks for bytecode generated by Dynamo. The hook can do some
    logging, as well as return a new code object to be used. Please refer
    to `BytecodeHook` for the hook signature.
    """
    ...

class ConvertFrame:
    def __init__(self, compiler_fn: CompilerFn, hooks: Hooks, package: Optional[CompilePackage] = ...) -> None:
        ...
    
    def __call__(self, frame: DynamoFrameType, cache_entry: Optional[CacheEntry], hooks: Hooks, frame_state: dict[str, Union[int, FrameStateSizeEntry]], skip: int = ...) -> ConvertFrameReturn:
        ...
    


def convert_frame(compiler_fn: CompilerFn, hooks: Hooks, package: Optional[CompilePackage] = ...) -> ConvertFrame:
    """Try to convert a frame into an FX graph, if error leave frame unmodified"""
    ...

def replay(filename: str) -> None:
    ...

def first_real_inst_idx(code: CodeType) -> int:
    ...

class ConvertFrameProtocol(typing.Protocol):
    def __call__(self, frame: DynamoFrameType, cache_entry: Optional[CacheEntry], hooks: Hooks, frame_state: dict[str, Union[int, FrameStateSizeEntry]], *, skip: int = ...) -> ConvertFrameReturn:
        ...
    


class CatchErrorsWrapper:
    def __init__(self, callback: ConvertFrameProtocol, hooks: Hooks) -> None:
        ...
    
    def __call__(self, frame: DynamoFrameType, cache_entry: Optional[CacheEntry], frame_state: dict[str, Union[int, FrameStateSizeEntry]]) -> ConvertFrameReturn:
        ...
    


def catch_errors_wrapper(callback: ConvertFrameProtocol, hooks: Hooks) -> CatchErrorsWrapper:
    ...

