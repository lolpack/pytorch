"""
This type stub file was generated by pyright.
"""

import torch
import torch.fx
from typing import Optional, TYPE_CHECKING
from .base import VariableTracker
from .iter import IteratorVariable
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
Variable tracking implementations for list-like data structures in Dynamo.

This module provides specialized variable tracking for various collection types:
- Lists and list subclasses (including torch.nn.ModuleList, ParameterList)
- Tuples and named tuples
- Ranges and slices
- Collections.deque
- torch.Size with special proxy handling

The implementations support both mutable and immutable collections, iteration,
and common sequence operations. Each collection type has a dedicated Variable
class that handles its unique behaviors while integrating with Dynamo's
variable tracking system.
"""
if TYPE_CHECKING:
    ...
class BaseListVariable(VariableTracker):
    @staticmethod
    def cls_for_instance(obj):
        ...
    
    @staticmethod
    def cls_for(obj):
        ...
    
    def __init__(self, items: list[VariableTracker], **kwargs) -> None:
        ...
    
    def modified(self, items, **kwargs): # -> Self:
        ...
    
    @property
    def value(self): # -> Any:
        ...
    
    def debug_repr_helper(self, prefix, suffix):
        ...
    
    def as_python_constant(self): # -> Any:
        ...
    
    def as_proxy(self): # -> Any:
        ...
    
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): # -> Self | VariableTracker:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[VariableTracker]:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class RangeVariable(BaseListVariable):
    def __init__(self, items, **kwargs) -> None:
        ...
    
    def debug_repr(self): # -> str:
        ...
    
    def python_type(self): # -> type[range]:
        ...
    
    def start(self):
        ...
    
    def stop(self):
        ...
    
    def step(self):
        ...
    
    def range_length(self): # -> Literal[0]:
        ...
    
    def apply_index(self, index): # -> VariableTracker:
        ...
    
    def apply_slice(self, slice): # -> RangeVariable:
        ...
    
    def as_python_constant(self): # -> range:
        ...
    
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): # -> RangeVariable | VariableTracker:
        ...
    
    def as_proxy(self): # -> range:
        ...
    
    def unpack_var_sequence(self, tx=...): # -> list[VariableTracker]:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> VariableTracker:
        ...
    


class CommonListMethodsVariable(BaseListVariable):
    """
    Implement methods common to List and other List-like things
    """
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class ListVariable(CommonListMethodsVariable):
    def python_type(self): # -> type[list[Any]]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def debug_repr(self): # -> str:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def var_getattr(self, tx, name): # -> BuiltinVariable | UserDefinedClassVariable | VariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    


class DequeVariable(CommonListMethodsVariable):
    def __init__(self, items, maxlen=..., **kwargs) -> None:
        ...
    
    def python_type(self): # -> type[deque[Any]]:
        ...
    
    def debug_repr(self): # -> str:
        ...
    
    def as_python_constant(self): # -> deque[Any]:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class TupleVariable(BaseListVariable):
    def python_type(self): # -> type[tuple[Any, ...]]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def debug_repr(self): # -> str:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def var_getattr(self, tx, name): # -> BuiltinVariable | UserDefinedClassVariable | VariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    


class SizeVariable(TupleVariable):
    """torch.Size(...)"""
    _nonvar_fields = ...
    def __init__(self, items: list[VariableTracker], proxy: Optional[torch.fx.Proxy] = ..., **kwargs) -> None:
        ...
    
    def debug_repr(self): # -> str:
        ...
    
    def python_type(self): # -> type[Size]:
        ...
    
    def as_proxy(self): # -> Proxy | Size:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[VariableTracker]:
        ...
    
    def numel(self, tx): # -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def get_item_dyn(self, tx: InstructionTranslator, arg: VariableTracker): # -> SizeVariable | VariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    


class NamedTupleVariable(TupleVariable):
    _nonvar_fields = ...
    def __init__(self, items, tuple_cls, **kwargs) -> None:
        ...
    
    def is_namedtuple(self): # -> TypeIs[Callable[..., object]] | Literal[False]:
        ...
    
    def is_structseq(self): # -> bool:
        ...
    
    def fields(self): # -> tuple[str, ...]:
        ...
    
    def debug_repr(self): # -> str:
        ...
    
    def python_type(self): # -> Any:
        ...
    
    def as_python_constant(self):
        ...
    
    def as_proxy(self):
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> BuiltinVariable | UserDefinedClassVariable | VariableTracker | UserMethodVariable | UserFunctionVariable:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    


class SliceVariable(VariableTracker):
    def __init__(self, items, **kwargs) -> None:
        ...
    
    def debug_repr(self):
        ...
    
    def as_proxy(self): # -> slice[Any, Any, Any]:
        ...
    
    def python_type(self): # -> type[slice[Any, Any, Any]]:
        ...
    
    def as_python_constant(self): # -> slice[Any, Any | LazyVariableTracker | VariableTracker, Any]:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> GetAttrVariable | VariableTracker:
        ...
    


class ListIteratorVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(self, items, index: int = ..., **kwargs) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def next_variable(self, tx):
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]): # -> VariableTracker:
        ...
    
    def python_type(self): # -> type[Iterator[Any]]:
        ...
    
    def as_python_constant(self): # -> Iterator[Any]:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[Any]:
        ...
    
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]:
        ...
    
    def reconstruct(self, codegen: PyCodegen) -> None:
        ...
    


class TupleIteratorVariable(ListIteratorVariable):
    ...


