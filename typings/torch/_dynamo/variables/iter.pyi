"""
This type stub file was generated by pyright.
"""

from typing import Optional, TYPE_CHECKING, Union
from .base import VariableTracker
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
This module provides iterator-related variable tracking functionality for Dynamo.
It implements variable classes for handling Python iterators and itertools functions
during symbolic execution and tracing.

The module includes:
- Base iterator variable classes for tracking iterator state
- Implementations of built-in iterators (zip, map, filter)
- Support for itertools functions (product, accumulate, combinations, etc.)
- Mutation tracking and reconstruction capabilities for iterator operations

These classes integrate with Dynamo's variable tracking system to enable proper
handling of iterator operations during code transformation and optimization.
"""
if TYPE_CHECKING:
    ...
MAX_ITERATOR_LIMIT = ...
class ItertoolsVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def as_python_constant(self): # -> Any:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class IteratorVariable(VariableTracker):
    def __init__(self, **kwargs) -> None:
        ...
    
    def next_variable(self, tx):
        ...
    
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]:
        ...
    
    def force_apply_to_var_sequence(self, tx, fn) -> None:
        ...
    
    def has_force_unpack_var_sequence(self, tx) -> bool:
        ...
    


class RepeatIteratorVariable(IteratorVariable):
    def __init__(self, item: VariableTracker, **kwargs) -> None:
        ...
    
    def next_variable(self, tx): # -> VariableTracker:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


class CountIteratorVariable(IteratorVariable):
    def __init__(self, item: int = ..., step: int = ..., **kwargs) -> None:
        ...
    
    def next_variable(self, tx): # -> int | <subclass of int and VariableTracker> | VariableTracker:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


class CycleIteratorVariable(IteratorVariable):
    def __init__(self, iterator: IteratorVariable, saved: Optional[list[VariableTracker]] = ..., saved_index: int = ..., item: Optional[VariableTracker] = ..., **kwargs) -> None:
        ...
    
    def next_variable(self, tx): # -> VariableTracker | None:
        ...
    


class ZipVariable(IteratorVariable):
    """
    Represents zip(*iterables)
    """
    _nonvar_fields = ...
    def __init__(self, iterables: list[Union[list[VariableTracker], VariableTracker]], strict: bool = ..., **kwargs) -> None:
        ...
    
    def python_type(self): # -> type[zip[Any]]:
        ...
    
    def has_unpack_var_sequence(self, tx) -> bool:
        ...
    
    def unpack_var_sequence(self, tx) -> list[VariableTracker]:
        ...
    
    def next_variable(self, tx): # -> TupleVariable:
        ...
    
    def reconstruct_items(self, codegen: PyCodegen): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


class MapVariable(ZipVariable):
    """
    Represents map(fn, *iterables)
    """
    def __init__(self, fn: VariableTracker, iterables: list[Union[list[VariableTracker], VariableTracker]], **kwargs) -> None:
        ...
    
    def python_type(self): # -> type[map[Any]]:
        ...
    
    def has_unpack_var_sequence(self, tx) -> bool:
        ...
    
    def next_variable(self, tx): # -> VariableTracker:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


class FilterVariable(IteratorVariable):
    """
    Represents filter(fn, iterable)
    """
    _nonvar_fields = ...
    def __init__(self, fn: VariableTracker, iterable: Union[list[VariableTracker], VariableTracker], **kwargs) -> None:
        ...
    
    def python_type(self): # -> type[filter[Any]]:
        ...
    
    def has_unpack_var_sequence(self, tx) -> bool:
        ...
    
    def unpack_var_sequence(self, tx) -> list[VariableTracker]:
        ...
    
    def next_variable(self, tx): # -> VariableTracker:
        ...
    
    def reconstruct_items(self, codegen: PyCodegen): # -> None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


