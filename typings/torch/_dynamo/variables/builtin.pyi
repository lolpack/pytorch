"""
This type stub file was generated by pyright.
"""

import contextlib
import typing
from collections.abc import Sequence
from typing import Callable, TYPE_CHECKING, Union
from .base import VariableTracker
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
Built-in function and type variable tracking for TorchDynamo's symbolic execution.

This module contains variable tracker classes for Python built-in functions, types,
and operations during graph compilation. It handles symbolic execution of:

- Built-in functions (len, getattr, isinstance, etc.)
- Type constructors (int, float, str, list, dict, etc.)
- Built-in operators and methods
- Special Python constructs (super, hasattr, etc.)

Key classes:
- BuiltinVariable: Tracks built-in functions and handles their execution
- TypeVariable: Manages type constructor calls and type checking
- SuperVariable: Handles super() calls in class hierarchies

These variable trackers ensure that built-in Python operations are correctly
handled during symbolic execution, either by executing them directly when safe
or by creating appropriate graph nodes when needed.
"""
if TYPE_CHECKING:
    ...
log = ...
IN_PLACE_DESUGARING_MAP = ...
_HandlerCallback = Callable[["InstructionTranslator", typing.Any, typing.Any], VariableTracker]
_TrackersType = Union[type[VariableTracker], tuple[type[VariableTracker], ...]]
polyfill_fn_mapping = ...
class BuiltinVariable(VariableTracker):
    """
    A VariableTracker that represents a built-in value (functions and operators).
    A lot of the code here assumes it will be a function object.

    The BuiltinVariable class wraps Python built-in functions (like len, isinstance, etc.)
    and operators (like +, -, *, etc.) to enable symbolic execution during tracing. This allows
    Dynamo to properly handle these operations when converting Python code to FX graphs while
    maintaining correct semantics and enabling optimizations.
    """
    _SENTINEL = ...
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source): # -> Self:
        ...
    
    def can_constant_fold_through(self): # -> bool:
        ...
    
    def can_insert_in_graph(self): # -> bool:
        ...
    
    def __init__(self, fn, **kwargs) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def as_python_constant(self): # -> Any:
        ...
    
    def as_proxy(self):
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def constant_args(self, *args, **kwargs): # -> bool:
        ...
    
    def tensor_args(self, *args): # -> bool:
        ...
    
    def tensor_args_type(self, arg_types): # -> bool:
        ...
    
    def python_and_tensor_constant_only(self, *args, **kwargs): # -> bool:
        ...
    
    @staticmethod
    def unwrap_unspec_args_kwargs(args, kwargs): # -> tuple[list[Any], dict[Any, Any]]:
        ...
    
    def has_constant_handler(self, args, kwargs): # -> bool:
        ...
    
    call_function_handler_cache: dict[tuple[object, ...], Callable[[InstructionTranslator, Sequence[VariableTracker], dict[str, VariableTracker]], VariableTracker,],] = ...
    def call_function(self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    call_int = ...
    call_float = ...
    def call_bool(self, tx: InstructionTranslator, arg): # -> SymNodeVariable | VariableTracker | None:
        ...
    
    def call_str(self, tx: InstructionTranslator, arg): # -> VariableTracker | ListIteratorVariable | None:
        ...
    
    call_min = ...
    call_max = ...
    def call_abs(self, tx: InstructionTranslator, arg: VariableTracker): # -> VariableTracker:
        ...
    
    def call_pos(self, tx: InstructionTranslator, arg: VariableTracker): # -> VariableTracker:
        ...
    
    def call_index(self, tx: InstructionTranslator, arg: VariableTracker): # -> VariableTracker:
        ...
    
    def call_round(self, tx: InstructionTranslator, arg, *args, **kwargs): # -> VariableTracker:
        ...
    
    def call_range(self, tx: InstructionTranslator, *args): # -> RangeVariable | None:
        ...
    
    def call_slice(self, tx: InstructionTranslator, *args): # -> SliceVariable:
        ...
    
    def call_iter(self, tx: InstructionTranslator, obj, *args, **kwargs): # -> VariableTracker | IteratorVariable:
        ...
    
    call_tuple = ...
    call_list = ...
    def call_callable(self, tx: InstructionTranslator, arg): # -> VariableTracker | None:
        ...
    
    def call_cast(self, _, *args, **kwargs):
        ...
    
    def call_dict(self, tx: InstructionTranslator, *args, **kwargs): # -> VariableTracker | ListIteratorVariable:
        ...
    
    @staticmethod
    def call_custom_dict(tx: InstructionTranslator, user_cls, *args, **kwargs): # -> VariableTracker | ListIteratorVariable:
        ...
    
    @staticmethod
    def call_custom_dict_fromkeys(tx: InstructionTranslator, user_cls, *args, **kwargs): # -> ConstDictVariable | DefaultDictVariable:
        ...
    
    def call_set(self, tx: InstructionTranslator, *args, **kwargs): # -> SetVariable:
        ...
    
    def call_frozenset(self, tx: InstructionTranslator, *args, **kwargs): # -> FrozensetVariable:
        ...
    
    def call_zip(self, tx: InstructionTranslator, *args, **kwargs): # -> ZipVariable:
        ...
    
    def call_len(self, tx: InstructionTranslator, *args, **kwargs):
        ...
    
    def call_getitem(self, tx: InstructionTranslator, *args, **kwargs):
        ...
    
    def call_isinstance(self, tx: InstructionTranslator, arg, isinstance_type): # -> VariableTracker:
        ...
    
    def call_issubclass(self, tx: InstructionTranslator, left_ty, right_ty): # -> ConstantVariable:
        """Checks if first arg is subclass of right arg"""
        ...
    
    def call_super(self, tx: InstructionTranslator, a, b): # -> SuperVariable:
        ...
    
    def call_next(self, tx: InstructionTranslator, arg: VariableTracker): # -> VariableTracker:
        ...
    
    def call_hasattr(self, tx: InstructionTranslator, obj, attr): # -> ConstantVariable | None:
        ...
    
    def call_map(self, tx: InstructionTranslator, fn, *seqs): # -> MapVariable:
        ...
    
    def call_filter(self, tx: InstructionTranslator, fn, seq): # -> FilterVariable:
        ...
    
    def call_getattr(self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker, default=...): # -> VariableTracker | TupleVariable | Any | GetAttrVariable | UserDefinedClassVariable | NNModuleVariable | UnspecializedNNModuleVariable | UserMethodVariable | UserFunctionVariable | DelayGraphBreakVariable | WrapperUserMethodVariable | BaseHOPVariable | SkipFunctionVariable | TorchInGraphFunctionVariable | LazyVariableTracker | BuiltinVariable | ConstDictVariable | NNModuleHooksDictVariable | None:
        ...
    
    def call_setattr(self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker, val: VariableTracker): # -> ConstantVariable | VariableTracker | ExceptionVariable | TensorVariable | None:
        ...
    
    def call_delattr(self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker): # -> VariableTracker:
        ...
    
    def call_type(self, tx: InstructionTranslator, obj: VariableTracker): # -> Any:
        ...
    
    def call_reversed(self, tx: InstructionTranslator, obj: VariableTracker): # -> TupleVariable | None:
        ...
    
    def call_sorted(self, tx: InstructionTranslator, obj: VariableTracker, **kwargs: VariableTracker): # -> ListVariable | None:
        ...
    
    def call_neg(self, tx: InstructionTranslator, a): # -> VariableTracker | SymNodeVariable | None:
        ...
    
    def call_format(self, tx: InstructionTranslator, _format_string, *args, **kwargs): # -> VariableTracker | StringFormatVariable:
        ...
    
    def call_id(self, tx: InstructionTranslator, *args): # -> VariableTracker:
        ...
    
    def call_deepcopy(self, tx: InstructionTranslator, x):
        ...
    
    def call_and_(self, tx: InstructionTranslator, a, b): # -> VariableTracker | SymNodeVariable | SetVariable | None:
        ...
    
    call_iand = ...
    def call_or_(self, tx: InstructionTranslator, a, b): # -> VariableTracker | SymNodeVariable | SetVariable | None:
        ...
    
    call_ior = ...
    def call_not_(self, tx: InstructionTranslator, a): # -> VariableTracker | SymNodeVariable | None:
        ...
    
    def call_contains(self, tx: InstructionTranslator, a: VariableTracker, b: VariableTracker): # -> VariableTracker:
        ...
    


@contextlib.contextmanager
def dynamo_disable_grad(tx): # -> Generator[None, Any, None]:
    ...

