"""
This type stub file was generated by pyright.
"""

import builtins
import types
import torch
from collections.abc import Sequence
from types import FunctionType
from typing import Any, Callable, Optional, TYPE_CHECKING, TypeVar
from typing_extensions import Never
from .. import variables
from ..source import AttrSource
from .base import VariableTracker
from .constant import ConstantVariable
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator
from torch._higher_order_ops.triton_kernel_wrap import TritonGridType, TritonHOPifier, TritonKernelType

"""
Function-related variable tracking classes for Dynamo's symbolic execution.

This module contains classes that track different types of functions during graph
compilation, including:
- User-defined functions and methods
- Built-in functions and methods
- Wrapped functions (e.g. from decorators)
- Special function types (e.g. functools.partial)
- Triton kernels and related function types

These classes are responsible for:
- Tracking function calls and their arguments
- Managing function closures and cell variables
- Handling function attributes and special methods
- Maintaining guards for function identity and closure contents
- Supporting function inlining and specialization
- Enabling proper symbolic execution of different function types

The variable trackers here work together with the rest of Dynamo to enable
accurate graph capture while handling Python's various function-related behaviors.
"""
if TYPE_CHECKING:
    ...
_F = TypeVar("_F", bound=Callable)
CO_VARARGS = ...
CO_VARKEYWORDS = ...
_spec_cache = ...
class FunctionSpec:
    def __init__(self, func: FunctionType) -> None:
        ...
    
    def update_defaults(self, func: FunctionType): # -> None:
        ...
    


def bind_args_cached(func, tx, fn_source, args, kwargs): # -> dict[Any, Any]:
    ...

def wrap_bound_arg(tx: InstructionTranslator, val, source=...): # -> VariableTracker | Any | LazyVariableTracker:
    ...

def wrap_args_kwargs(tx: InstructionTranslator, result): # -> None:
    ...

def init_cellvars(parent, result: dict[str, VariableTracker], code): # -> None:
    """
    Update `result` to add mapping from local name to new cells created
    directly by `code`, or update SideEffects in `parent` if the a local cell is
    already in `result` (cell argument).
    """
    ...

fn_known_dunder_attrs = ...
def fn_var_getattr(tx, fn, source, name): # -> LazyVariableTracker | Any:
    ...

class BaseUserFunctionVariable(VariableTracker):
    def get_filename(self):
        ...
    
    def get_name(self):
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    
    def inspect_parameter_names(self): # -> list[str]:
        ...
    
    def closure_vars(self, tx): # -> dict[Any, Any]:
        ...
    


class UserFunctionVariable(BaseUserFunctionVariable):
    """Some unsupported user-defined global function"""
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source): # -> Self:
        ...
    
    def __init__(self, fn, is_constant=..., **kwargs) -> None:
        ...
    
    def as_python_constant(self): # -> FunctionType:
        ...
    
    def self_args(self): # -> list[Any]:
        ...
    
    def get_function(self): # -> FunctionType:
        ...
    
    def get_code(self): # -> CodeType:
        ...
    
    def python_type(self): # -> type[FunctionType]:
        ...
    
    def has_self(self): # -> bool:
        ...
    
    def get_globals(self): # -> dict[str, Any]:
        ...
    
    def bind_args(self, parent, args, kwargs) -> dict[str, VariableTracker]:
        """
        Assume `args` and `kwargs` are VariableTracker arguments for a call to
        this function, create new bindings for initial locals.
        """
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name: str): # -> GetAttrVariable | LazyVariableTracker | Any:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class BuiltinMethodVariable(BaseUserFunctionVariable):
    def __init__(self, fn, is_constant=..., **kwargs) -> None:
        ...
    
    @staticmethod
    def is_supported_builtin_method(obj): # -> Literal[False]:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class LocalGeneratorObjectVariable(VariableTracker):
    def __init__(self, code: types.CodeType, f_globals, inline_tracer: Optional[InstructionTranslator], **kwargs) -> None:
        ...
    
    def get_code(self): # -> CodeType:
        ...
    
    def get_filename(self): # -> str:
        ...
    
    def get_name(self): # -> str:
        ...
    
    def get_function(self):
        ...
    
    def has_self(self): # -> Literal[False]:
        ...
    
    def __name__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def bind_args(self, tx, args, kwargs):
        ...
    
    def get_globals(self):
        ...
    
    def python_type(self): # -> type[GeneratorType[Any, Any, Any]]:
        ...
    
    def next_variable(self, tx): # -> VariableTracker | ListIteratorVariable:
        ...
    
    def has_unpack_var_sequence(self, tx): # -> Literal[False]:
        ...
    
    def has_force_unpack_var_sequence(self, tx) -> builtins.bool:
        ...
    
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]:
        ...
    
    def force_apply_to_var_sequence(self, tx, fn) -> None:
        ...
    
    def call_method(self, tx: InstructionTranslator, name: str, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class ContextlibContextManagerLocalGeneratorObjectVariable(LocalGeneratorObjectVariable):
    """
    .. note::

        This is only used when the function is annotated with @contextlib.contextmanager

        It is a special case of a generator function as we do not allow return a context manager
        from a torch.compile function.
    """
    ...


class LocalGeneratorFunctionVariable(BaseUserFunctionVariable):
    """functions that behaves like iterators

    .. note::

        This is a wrapper around (Nested)UserFunctionVariable
    """
    def __init__(self, vt: VariableTracker, *, generator_cls=..., **kwargs) -> None:
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class FunctionDecoratedByContextlibContextManagerVariable(LocalGeneratorFunctionVariable):
    """
    .. note::

        This is only used when the function is annotated with @contextlib.contextmanager
    """
    def __init__(self, vt, **kwargs) -> None:
        ...
    


class UserMethodVariable(UserFunctionVariable):
    """Some unsupported user-defined method"""
    def __init__(self, fn, obj, **kwargs) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def self_args(self): # -> list[Any]:
        ...
    
    def python_type(self): # -> type[MethodType]:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def inspect_parameter_names(self): # -> list[str]:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name: str): # -> Any | GetAttrVariable | LazyVariableTracker:
        ...
    


class WrappedUserMethodVariable(UserMethodVariable):
    def __init__(self, wrapped, context, **kwargs) -> None:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def reconstruct(self, codegen): # -> None:
        ...
    


class WrappedUserFunctionVariable(UserFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def reconstruct(self, codegen): # -> None:
        ...
    


def invoke_and_store_as_constant(tx: InstructionTranslator, fn, name, args, kwargs): # -> Any:
    ...

class NestedUserFunctionVariable(BaseUserFunctionVariable):
    _nonvar_fields = ...
    def __init__(self, fn_name, code, f_globals, defaults, kwdefaults, annotations, closure, wrapped_fn=..., **kwargs) -> None:
        ...
    
    def self_args(self): # -> list[Any]:
        ...
    
    def get_code(self):
        ...
    
    def python_type(self): # -> type[FunctionType]:
        ...
    
    def get_function(self): # -> FunctionType:
        ...
    
    def call_setattr(self, tx: InstructionTranslator, name_var: VariableTracker, val: VariableTracker): # -> ConstantVariable:
        ...
    
    def call_method(self, tx, name, args, kwargs): # -> ConstantVariable | VariableTracker:
        ...
    
    def has_closure(self): # -> bool:
        ...
    
    def const_getattr(self, tx, name): # -> Any:
        ...
    
    def has_self(self): # -> Literal[False]:
        ...
    
    def get_globals(self): # -> dict[Any, Any]:
        ...
    
    def bind_args(self, parent, args, kwargs): # -> dict[str, Any]:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    


class WrappedNestedUserFunctionVariable(NestedUserFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def reconstruct(self, codegen): # -> None:
        ...
    


class SkipFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, value, reason=..., **kwargs) -> None:
        ...
    
    def as_python_constant(self): # -> Any:
        ...
    
    @classmethod
    def create_with_source(cls, value, source): # -> Self:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name): # -> VariableTracker:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name: str): # -> GetAttrVariable | LazyVariableTracker | Any:
        ...
    


class WrappedSkipFunctionVariable(SkipFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def reconstruct(self, codegen): # -> None:
        ...
    


class WrapperUserFunctionVariable(VariableTracker):
    """
    Used to represent a wrapper object that contains the actual callable as an
    attribute. For example, torch.jit.script/trace have the original function at
    their _torchdynamo_inline attribute. Similarly, functions with
    __script_if_tracing_wrapper have the original attr at "__original_fn".
    """
    def __init__(self, wrapper_obj, attr_to_trace, **kwargs) -> None:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> Any | VariableTracker:
        ...
    
    def self_args(self): # -> list[Any]:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class WrapperUserMethodVariable(WrapperUserFunctionVariable):
    """
    Similar to WrapperUserFunctionVariable, but for methods. The only delta is
    saving the vt for `self` object of the method which is then used by
    WrapperUserFunctionVariable in `call_function` method.
    """
    def __init__(self, wrapper_obj, attr_to_trace, self_obj, **kwargs) -> None:
        ...
    
    def self_args(self): # -> list[Any]:
        ...
    


class CollectiveFunctionRewriteVariable(UserFunctionVariable):
    """
    Some of the torch.distributed.* collective APIs are possible to rewrite to 'traceable' collectives.

    This class provides both a way to check if a function is remappable, and perform the remapping.

    In the case that a function is 'remappable' but only for some combinations of call-time arguments,
    we check the args at `call_function` time and fall back to graph-breaking if needed.  This is no worse
    than status-quo as we currently graph-break on all distributed.* collectives.
    """
    def __init__(self, fn, *, replacement_var, **kwargs) -> None:
        ...
    
    @staticmethod
    def create(tx: InstructionTranslator, old_fn, source, **options): # -> CollectiveFunctionRewriteVariable:
        ...
    
    @staticmethod
    def can_rewrite(variable): # -> TypeIs[FunctionType] | bool:
        ...
    
    @staticmethod
    def rewrite(tx: InstructionTranslator, fn): # -> tuple[Any, AttrSource]:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class FunctoolsWrapsVariable(UserFunctionVariable):
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class CollectionsNamedTupleFunction(UserFunctionVariable):
    def as_python_constant(self): # -> FunctionType:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class FunctoolsPartialVariable(VariableTracker):
    def __init__(self, func: VariableTracker, args, keywords, **kwargs) -> None:
        ...
    
    def python_type(self): # -> type[partial[Any]]:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def get_function(self): # -> partial[Any]:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name: str): # -> VariableTracker | ListVariable | ConstDictVariable | GetAttrVariable:
        ...
    
    def as_python_constant(self): # -> partial[Any]:
        ...
    
    def guard_as_python_constant(self): # -> partial[Any]:
        """Similar to as_python_constant(), but add ID_MATCH guards to try to force things to become constants"""
        ...
    


class PolyfilledFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source): # -> Self:
        ...
    
    def __init__(self, fn: _F, **kwargs) -> None:
        ...
    
    @property
    def polyfill_fn(self) -> _F:
        ...
    
    def can_constant_fold_through(self): # -> Any | bool:
        ...
    
    def get_function(self): # -> _F:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def as_python_constant(self): # -> _F:
        ...
    


class TracebackVariable(VariableTracker):
    def call_function(self, tx, args, kwargs): # -> None:
        ...
    


class SysFunctionVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None:
        ...
    
    def exc_info(self, tx): # -> TupleVariable:
        ...
    
    def exception(self, tx): # -> VariableTracker:
        ...
    
    def call_function(self, tx, args, kwargs): # -> TupleVariable | VariableTracker:
        ...
    


class DynamoTritonHOPifier(TritonHOPifier):
    def raise_unsupported(self, msg: str) -> Never:
        ...
    
    def is_callable(self, maybe_callable: Any) -> bool:
        ...
    
    def get_value(self, val: Any) -> Any:
        ...
    
    def check_grid(self, grid) -> tuple[torch.fx.proxy.Proxy, ...]:
        ...
    
    def call_grid(self, grid, meta, tx):
        ...
    
    def call_user_defined_fn(self, user_fn, args, kwargs, tx, variable): # -> VariableTracker:
        ...
    
    def wrap_user_defined_obj(self, user_obj, tx, variable, name):
        ...
    
    def maybe_unpack_configs(self, configs, tx): # -> list[Any]:
        ...
    
    def maybe_unpack_heuristic_result(self, result: Any) -> Any:
        ...
    
    def call_getitem(self, variable: TritonKernelVariable, args: Sequence[Any]) -> TritonKernelVariable:
        ...
    
    def call_HOP(self, variable, grids, combined_args_raw, tx) -> ConstantVariable:
        ...
    


dynamo_triton_hopifier_singleton = ...
class TritonKernelVariable(VariableTracker):
    grid: TritonGridType
    kernel: TritonKernelType
    kernel_idx: Optional[int]
    kernel_source: AttrSource
    def __init__(self, kernel, kernel_idx, grid, **kwargs) -> None:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def specialize_symbolic(self, arg: Any) -> Any:
        ...
    


class TMADescriptorExperimentalVariable(VariableTracker):
    def __init__(self, data_ptr: variables.DataPtrVariable, dims: list[ConstantVariable], block_dims: list[ConstantVariable], element_size: ConstantVariable, **kwargs) -> None:
        ...
    
    def to_metadata(self): # -> TMAExperimentalMetadata:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def get_tensor(self): # -> TensorVariable:
        ...
    


class TMADescriptorStableVariable(VariableTracker):
    def __init__(self, tensor: variables.TensorVariable, block_shape: variables.ListVariable, **kwargs) -> None:
        ...
    
    def to_metadata(self): # -> TMAStableMetadata:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def get_tensor(self) -> variables.TensorVariable:
        ...
    


class CreateTMADescriptorExperimentalVariable(VariableTracker):
    def __init__(self, rank: int, **kwargs) -> None:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class CreateTMADescriptorStableVariable(VariableTracker):
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


