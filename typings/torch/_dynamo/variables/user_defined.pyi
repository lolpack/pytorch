"""
This type stub file was generated by pyright.
"""

import functools
from typing import TYPE_CHECKING
from .. import variables
from .base import VariableTracker
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
This module contains variable classes for handling user-defined objects in Dynamo's tracing system.

The key classes are:
- UserDefinedVariable: Base class for representing custom Python objects
- UserDefinedClassVariable: Handles Python class objects/types
- UserDefinedObjectVariable: Fallback class for instance objects, with support for method calls,
  attribute access, and other Python object behaviors.
- Specialized subclasses for common patterns:
  - UserDefinedDictVariable: For dict subclasses
  - UserDefinedTupleVariable: For tuple subclasses
  - FrozenDataClassVariable: Special handling of frozen dataclasses
  - MutableMappingVariable: For collections.abc.MutableMapping subclasses

Dynamo specializes to VariableTracker subclasses like FrozenDataClassVariable if available; if no
subclass qualifies, it falls back to UserDefinedObjectVariable.

These classes help Dynamo track and handle arbitrary Python objects during tracing,
maintaining proper semantics while enabling optimizations where possible.
"""
if TYPE_CHECKING:
    ...
def is_standard_setattr(val): # -> bool:
    ...

def is_standard_delattr(val): # -> bool:
    ...

def is_forbidden_context_manager(ctx): # -> bool:
    ...

class UserDefinedVariable(VariableTracker):
    value: object
    ...


class UserDefinedClassVariable(UserDefinedVariable):
    value: type[object]
    def __init__(self, value, **kwargs) -> None:
        ...
    
    def as_python_constant(self): # -> type[object]:
        ...
    
    def as_proxy(self): # -> type[object]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @staticmethod
    @functools.cache
    def supported_c_new_functions(): # -> set[Any]:
        ...
    
    @staticmethod
    def is_supported_new_method(value): # -> bool:
        ...
    
    def can_constant_fold_through(self): # -> bool:
        ...
    
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key): # -> bool:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def is_standard_new(self): # -> bool:
        """Check for __new__ being overridden"""
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    
    def const_getattr(self, tx: InstructionTranslator, name): # -> str | Any:
        ...
    


class UserDefinedExceptionClassVariable(UserDefinedClassVariable):
    @property
    def fn(self): # -> type[object]:
        ...
    
    def python_type(self): # -> type[object]:
        ...
    


class NO_SUCH_SUBOBJ:
    ...


def call_random_fn(tx, fn, args, kwargs): # -> ConstantVariable:
    ...

class UserDefinedObjectVariable(UserDefinedVariable):
    """
    Mostly objects of defined type.  Catch-all for something where we only know the type.
    """
    _nonvar_fields = ...
    def __init__(self, value, *, value_type=..., cls_source=..., base_cls_vt=..., init_args=..., **kwargs) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def is_underlying_vt_modified(self, side_effects): # -> Literal[False]:
        ...
    
    def python_type(self): # -> Any:
        ...
    
    def as_python_constant(self): # -> object:
        ...
    
    def guard_as_python_constant(self): # -> object:
        ...
    
    def torch_function_check(self): # -> None:
        ...
    
    def get_torch_fn(self, tx): # -> VariableTracker:
        ...
    
    def call_torch_function(self, tx: InstructionTranslator, fn, types, args, kwargs): # -> VariableTracker:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def method_setattr_standard(self, tx: InstructionTranslator, name, value, directly_update_dict=...): # -> Any | ConstantVariable:
        ...
    
    def needs_slow_setattr(self): # -> bool:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[LazyVariableTracker] | list[VariableTracker]:
        ...
    
    def next_variable(self, tx): # -> VariableTracker:
        ...
    
    def is_supported_random(self): # -> bool:
        ...
    
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def should_skip_descriptor_setter(self, attr_name): # -> bool:
        ...
    
    def try_get_descritor_and_setter_py_func(self, attr_name): # -> tuple[Any, FunctionType] | None:
        ...
    
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key): # -> bool:
        ...
    
    def get_source_by_walking_mro(self, name): # -> GetItemSource:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> VariableTracker | GetAttrVariable | UserDefinedClassVariable | UnspecializedNNModuleVariable | NNModuleVariable | Any | UserMethodVariable | WrapperUserMethodVariable | BaseHOPVariable | SkipFunctionVariable | TorchInGraphFunctionVariable | UserFunctionVariable | LazyVariableTracker:
        ...
    
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    


class FrozenDataClassVariable(UserDefinedObjectVariable):
    @staticmethod
    def create(tx, value, source): # -> FrozenDataClassVariable:
        ...
    
    def __init__(self, value, fields=..., **kwargs) -> None:
        ...
    
    def as_python_constant(self):
        ...
    
    def as_proxy(self):
        ...
    
    def method_setattr_standard(self, tx: InstructionTranslator, name, value): # -> Any | ConstantVariable:
        ...
    
    def __repr__(self) -> str:
        ...
    


class SourcelessGraphModuleVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    


class UserDefinedExceptionObjectVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None:
        ...
    
    @property
    def fn(self): # -> Any:
        ...
    
    def call_method(self, tx, name, args, kwargs): # -> ConstantVariable | VariableTracker:
        ...
    
    @property
    def __context__(self): # -> ConstantVariable | ExceptionVariable:
        ...
    
    def set_context(self, context: variables.ExceptionVariable): # -> None:
        ...
    
    @property
    def exc_type(self): # -> Any:
        ...
    


class KeyedJaggedTensorVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj): # -> bool:
        ...
    
    def __init__(self, value, **kwargs) -> None:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name): # -> VariableTracker | GetAttrVariable | UserDefinedClassVariable | UnspecializedNNModuleVariable | NNModuleVariable | Any | UserMethodVariable | WrapperUserMethodVariable | BaseHOPVariable | SkipFunctionVariable | TorchInGraphFunctionVariable | UserFunctionVariable | LazyVariableTracker:
        ...
    


class IntWrapperVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj): # -> bool:
        ...
    


class RemovableHandleClass:
    ...


class RemovableHandleVariable(VariableTracker):
    REMOVED = ...
    def __init__(self, mutation_type=..., idx=..., **kwargs) -> None:
        ...
    
    def call_method(self, tx: InstructionTranslator, method_name, args, kwargs): # -> VariableTracker | None:
        ...
    
    def reconstruct(self, codegen: PyCodegen): # -> None:
        ...
    
    def python_type(self): # -> type[RemovableHandleClass]:
        ...
    


class UserDefinedDictVariable(UserDefinedObjectVariable):
    """
    Represents user defined objects that are subclasses of dict/OrderedDict.

    Internally, it uses a ConstDictVariable to represent the dict part of the
    variable tracker. For everything else, it falls back to
    UserDefinedObjectVariable.
    """
    _nonvar_fields = ...
    def __init__(self, value, dict_vt=..., **kwargs) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[LazyVariableTracker | VariableTracker | Any]:
        ...
    
    def is_underlying_vt_modified(self, side_effects):
        ...
    


class UserDefinedListVariable(UserDefinedObjectVariable):
    """
    Represents user defined objects that are subclasses of lists.

    Internally, it uses a ListVariable to represent the list part of the
    variable tracker. For everything else, it falls back to
    UserDefinedObjectVariable.
    """
    _nonvar_fields = ...
    def __init__(self, value, list_vt=..., **kwargs) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[VariableTracker]:
        ...
    
    def is_underlying_vt_modified(self, side_effects):
        ...
    


class UserDefinedTupleVariable(UserDefinedObjectVariable):
    """
    Represents user defined objects that are subclasses of tuple.

    Internally, it uses a TupleVariable to represent the tuple part of the
    variable tracker. For everything else, it falls back to
    UserDefinedObjectVariable.
    """
    _nonvar_fields = ...
    def __init__(self, value, tuple_vt=..., init_args=..., **kwargs) -> None:
        ...
    
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker:
        ...
    
    def unpack_var_sequence(self, tx): # -> list[VariableTracker]:
        ...
    


class MutableMappingVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, **kwargs) -> None:
        ...
    
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker:
        ...
    


class RandomVariable(UserDefinedObjectVariable):
    ...


