"""
This type stub file was generated by pyright.
"""

import torch.utils._pytree as python_pytree
import builtins
import optree
import optree._C
import torch.utils._cxx_pytree as cxx_pytree
from dataclasses import dataclass
from typing import Any, Callable, Literal, TYPE_CHECKING
from typing_extensions import Self
from ..decorators import substitute_in_graph
from collections.abc import Iterable

"""
Python polyfills for torch.utils.pytree
"""
if TYPE_CHECKING:
    ...
__all__: list[str] = ...
if python_pytree._cxx_pytree_dynamo_traceable:
    @substitute_in_graph(optree._C.is_dict_insertion_ordered, can_constant_fold_through=True)
    def _(*args: Any, **kwargs: Any) -> bool:
        ...
    
    __name = ...
    @substitute_in_graph(cxx_pytree.tree_is_leaf, can_constant_fold_through=True)
    def tree_is_leaf(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> bool:
        ...
    
    @substitute_in_graph(cxx_pytree.tree_iter, can_constant_fold_through=False)
    def tree_iter(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> Iterable[Any]:
        ...
    
    @substitute_in_graph(cxx_pytree.tree_leaves, can_constant_fold_through=True)
    def tree_leaves(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> list[Any]:
        ...
    
    class _Asterisk(str):
        __slots__ = ...
        def __new__(cls) -> Self:
            ...
        
        def __repr__(self) -> str:
            ...
        
    
    
    _asterisk = ...
    @dataclass(frozen=True)
    class PyTreeSpec:
        """Analog for :class:`optree.PyTreeSpec` in Python."""
        _children: tuple[PyTreeSpec, ...]
        _type: builtins.type | None
        _metadata: Any
        _entries: tuple[Any, ...]
        _unflatten_func: Callable[[Any | None, Iterable[PyTree]], PyTree] | None
        num_nodes: int = ...
        num_leaves: int = ...
        num_children: int = ...
        none_is_leaf: Literal[True] = ...
        namespace: Literal["torch"] = ...
        def __post_init__(self) -> None:
            ...
        
        def __repr__(self) -> str:
            ...
        
        def __len__(self) -> int:
            ...
        
        @property
        def type(self) -> builtins.type | None:
            ...
        
        def is_leaf(self) -> bool:
            ...
        
        def children(self) -> list[PyTreeSpec]:
            ...
        
        def child(self, index: int) -> PyTreeSpec:
            ...
        
        def entries(self) -> list[Any]:
            ...
        
        def entry(self, index: int) -> Any:
            ...
        
        def flatten_up_to(self, tree: PyTree) -> list[PyTree]:
            ...
        
        def unflatten(self, leaves: Iterable[Any]) -> PyTree:
            ...
        
    
    
    _LEAF_SPEC = ...
    @substitute_in_graph(cxx_pytree.tree_flatten, can_constant_fold_through=False)
    def tree_flatten(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> tuple[list[Any], PyTreeSpec]:
        ...
    
    @substitute_in_graph(cxx_pytree.tree_structure, can_constant_fold_through=False)
    def tree_structure(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> PyTreeSpec:
        ...
    
    @substitute_in_graph(cxx_pytree.tree_unflatten, can_constant_fold_through=False)
    def tree_unflatten(leaves: Iterable[Any], treespec: PyTreeSpec) -> PyTree:
        ...
    
    @substitute_in_graph(cxx_pytree.tree_map, can_constant_fold_through=True)
    def tree_map(func: Callable[..., Any], tree: PyTree, *rests: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> PyTree:
        ...
    
    @substitute_in_graph(cxx_pytree.tree_map_, can_constant_fold_through=True)
    def tree_map_(func: Callable[..., Any], tree: PyTree, *rests: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> PyTree:
        ...
    
