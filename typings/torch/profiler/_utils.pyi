"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import TYPE_CHECKING
from torch.autograd.profiler import profile

if TYPE_CHECKING:
    ...
traverse_dfs = ...
traverse_bfs = ...
@dataclass
class EventMetrics:
    duration_time_ns: int = ...
    self_time_ns: int = ...
    idle_time_ns: int = ...
    queue_depth: int = ...
    @property
    def fraction_idle_time(self): # -> float:
        ...
    


@dataclass
class Interval:
    start: int
    end: int
    queue_depth: int = ...


class EventKey:
    def __init__(self, event) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def intervals_overlap(self, intervals: list[Interval]): # -> int:
        ...
    


class BasicEvaluation:
    def __init__(self, prof: profile) -> None:
        ...
    
    def compute_self_time(self): # -> None:
        """
        Computes event's self time(total time - time in child ops).
        """
        ...
    
    def compute_queue_depth(self): # -> list[Interval]:
        """
        Computes queue_depth at each event. This will calculate the queue depth data for
        All the events in the tree.
        This will return a list of Interval of queue depth data of cuda launch and kernels.
        """
        ...
    
    def compute_idle_time(self): # -> None:
        """
        Computes idle time of the profile.
        """
        ...
    
    def rank_events(self, length): # -> list[EventKey]:
        """
        Filter and Rank the events based on some heuristics:
        1) Events that are in the falling phase of the queue depth.
        2) Events that have a high idle_time, self_time difference.

        Parameters:
            length: The number of events to return.
        """
        ...
    
    def get_optimizable_events(self, length: int = ..., print_enable: bool = ...): # -> list[EventKey]:
        ...
    


def index_of_first_match(seq, predicate, start=..., end=...): # -> int | None:
    ...

def argmax(seq, key=..., start=..., end=...): # -> None:
    ...

def source_code_location(event): # -> Literal['No source code location found']:
    ...

