"""
This type stub file was generated by pyright.
"""

import enum
import traceback
import torch
from collections.abc import Iterator
from dataclasses import dataclass
from typing import Any, Optional, TypeVar
from torch.utils._python_dispatch import TorchDispatchMode

r"""
This module introduces CUDA Sanitizer, a tool for detecting synchronization errors between kernels ran on different streams.

It stores information on accesses to tensors to determine if they are synchronized
or not. When enabled in a python program and a possible data race is detected, a
detailed warning will be printed and the program will exit.

It can be enabled either by importing this module and calling
:func:`enable_cuda_sanitizer()` or by exporting the ``TORCH_CUDA_SANITIZER``
environment variable.
"""
DEFAULT_STREAM_ID = ...
TK = TypeVar("TK")
TVa = TypeVar("TVa")
TVb = TypeVar("TVb")
DataPtr = int
StreamId = int
EventId = int
SeqNum = int
logger = ...
FACTORY_FUNCTION_REGEX = ...
class AccessType(enum.Enum):
    READ = ...
    WRITE = ...
    def __str__(self) -> str:
        ...
    


@dataclass
class Access:
    r"""Stores information about a single access to a tensor by a kernel.

    Args:
        type: either AccessType.READ or AccessType.Write.
        seq_num: the sequential number of the kernel performing the access.
        stream: the stream id of the stream executing the kernel.
        operator: the schema of the launched kernel, which lists the
            arguments and return type.
        aliases: the arguments in the schema this access corresponds to.
        is_output: Whether the tensor was an output of the kernel.
        stack_trace: the stack summary object captured during access.
    """
    type: AccessType
    seq_num: SeqNum
    stream: StreamId
    operator: str
    aliases: list[str]
    is_output: bool
    stack_trace: traceback.StackSummary
    ...


class SynchronizationError(Exception):
    """Base class for errors detected by CUDA Sanitizer."""
    ...


class UnsynchronizedAccessError(SynchronizationError):
    """Stores information about two unsynchronized accesses to one data pointer."""
    def __init__(self, data_ptr: DataPtr, allocation_stack_trace: Optional[traceback.StackSummary], current_access: Access, previous_access: Access) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class CUDASanitizerErrors(Exception):
    """Wrapper class for errors reported by CUDA Sanitizer."""
    def __init__(self, errors: list[SynchronizationError]) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


@dataclass
class TensorInfo:
    r"""Stores information about a single tensor and recent accesses to it.

    Args:
        allocation_stack_trace: the stack summary object captured during tensor
            allocation. Can be ``None`` if the allocation wasn't caught by CSAN.
        reads: list of read accesses to the tensor that were performed since
            the last write.
        write: the last write access to the tensor.
    """
    allocation_stack_trace: Optional[traceback.StackSummary]
    reads: list[Access] = ...
    write: Optional[Access] = ...


class _TensorsAccessed:
    def __init__(self) -> None:
        ...
    
    def ensure_tensor_exists(self, data_ptr: DataPtr) -> None:
        ...
    
    def ensure_tensor_does_not_exist(self, data_ptr: DataPtr) -> None:
        ...
    
    def create_tensor(self, data_ptr: DataPtr, stack_trace: Optional[traceback.StackSummary]) -> None:
        ...
    
    def delete_tensor(self, data_ptr: DataPtr) -> None:
        ...
    
    def were_there_reads_since_last_write(self, data_ptr: DataPtr) -> bool:
        ...
    
    def get_allocation_stack_trace(self, data_ptr: DataPtr) -> Optional[traceback.StackSummary]:
        ...
    
    def get_write(self, data_ptr: DataPtr) -> Optional[Access]:
        ...
    
    def get_reads(self, data_ptr: DataPtr) -> list[Access]:
        ...
    
    def add_read(self, data_ptr: DataPtr, access: Access) -> None:
        ...
    
    def set_write(self, data_ptr: DataPtr, access: Access) -> None:
        ...
    


class StreamSynchronizations:
    def __init__(self) -> None:
        ...
    
    def create_stream(self, stream: StreamId) -> None:
        ...
    
    def create_event(self, event: EventId) -> None:
        ...
    
    def delete_event(self, event: EventId) -> None:
        ...
    
    def update_seq_num(self, stream: StreamId, seq_num: SeqNum) -> None:
        ...
    
    def record_state(self, event: EventId, stream: StreamId) -> None:
        ...
    
    def stream_wait_for_event(self, stream: StreamId, event: EventId) -> None:
        ...
    
    def all_streams_wait_for_event(self, event: EventId) -> None:
        ...
    
    def all_streams_wait_for_stream(self, stream: StreamId) -> None:
        ...
    
    def sync_all_streams(self) -> None:
        ...
    
    def is_ordered_after(self, current_stream: StreamId, seq_num: SeqNum, other_stream: StreamId) -> bool:
        ...
    


class EventHandler:
    """Analyzes CSAN trace for synchronization errors.

    Stores information on each stream's synchronizations with other streams as well
    as tensor accesses to determine whether a given kernel launch might cause a
    data race.
    """
    def __init__(self) -> None:
        ...
    


def zip_by_key(a: dict[TK, TVa], b: dict[TK, TVb]) -> Iterator[tuple[TK, TVa, TVb]]:
    ...

def zip_arguments(schema: torch.FunctionSchema, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Iterator[tuple[torch.Argument, Any]]:
    ...

class ArgumentHandler:
    def __init__(self) -> None:
        ...
    
    def parse_inputs(self, schema: torch.FunctionSchema, args: tuple[Any, ...], kwargs: dict[str, Any], *, is_factory: bool) -> None:
        ...
    
    def parse_outputs(self, schema: torch.FunctionSchema, outputs: Any, *, is_factory: bool) -> None:
        ...
    


class CUDASanitizerDispatchMode(TorchDispatchMode):
    def __init__(self) -> None:
        ...
    
    def __torch_dispatch__(self, func, types, args=..., kwargs=...):
        ...
    


class CUDASanitizer:
    """Manages the lifetime of a CUDASanitizer dispatch mode object.

    The CUDASanitizer class wraps the entering/exiting functions of the dispatch mode
    context manager in the enable function/destructor, respectively. This is to
    explicitly set the lifetime of the dispatch mode object to that of the application.
    This approach was deemed more elegant than using the atexit module.
    """
    def __init__(self) -> None:
        ...
    
    def enable(self): # -> None:
        ...
    
    def disable(self): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    


def enable_cuda_sanitizer(): # -> None:
    """Enable CUDA Sanitizer.

    The sanitizer will begin to analyze low-level CUDA calls invoked by torch functions
    for synchronization errors. All data races found will be printed to the standard
    error output along with stack traces of suspected causes. For best results, the
    sanitizer should be enabled at the very beginning of the program.
    """
    ...

cuda_sanitizer = ...
