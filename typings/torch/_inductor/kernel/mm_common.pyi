"""
This type stub file was generated by pyright.
"""

import sympy
from typing import Any
from torch._inductor.select_algorithm import SymbolicGridFn
from ..ir import Layout, TensorBox

log = ...
@SymbolicGridFn
def mm_grid(m, n, meta, *, cdiv): # -> tuple[Any, Literal[1], Literal[1]]:
    """
    The CUDA grid size for matmul triton templates.
    """
    ...

@SymbolicGridFn
def persistent_mm_grid(M: int, N: int, meta: dict[str, Any], *, cdiv, min): # -> tuple[Any, Literal[1], Literal[1]]:
    """Defines the grid for persistent kernels."""
    ...

@SymbolicGridFn
def persistent_grouped_mm_grid(*args): # -> tuple[Any, Literal[1], Literal[1]]:
    ...

def acc_type(dtype): # -> str:
    ...

def mm_options(config, sym_m, sym_n, sym_k, layout): # -> dict[str, bool | str]:
    """
    Common options to matmul triton templates.
    """
    ...

def tma_options() -> dict[str, Any]:
    ...

def persistent_mm_options(mat1, mat2): # -> dict[str, int]:
    ...

def scaled_mm_options(config, sym_m: sympy.core.numbers.Integer, sym_n: sympy.core.numbers.Integer, sym_k: sympy.core.numbers.Integer, layout: Layout, scale_a, scale_b, use_fast_accum: bool, device_tma: bool = ...) -> dict[str, Any]:
    ...

def mm_args(mat1, mat2, *others, layout=..., out_dtype=..., use_4x2_dim=..., mat2_transposed=...): # -> list[Any]:
    """
    Common arg processing for mm,bmm,addmm,etc
    """
    ...

def mm_config_kwargs(device, exclude_condition, dtype_size=...): # -> dict[str, Any] | dict[Any, Any]:
    ...

def addmm_epilogue(dtype, alpha, beta): # -> Callable[..., Any]:
    ...

def scale_mm_epilogue(): # -> Callable[..., Any]:
    """
    Create an epilogue function that applies scaling to matrix multiplication result
    using the given scale factors.

    Args:
        dtype: The data type of the output
        scale_a: Scale factor for matrix A
        scale_b: Scale factor for matrix B

    Returns:
        Epilogue function that takes the accumulator and applies scaling
    """
    ...

def check_supported_striding(mat_a: TensorBox, mat_b: TensorBox) -> None:
    ...

def is_batch_stride_largest(mat1, mat2, layout) -> bool:
    """
    Checking if the batch stride is the largest in the stride.
    """
    ...

