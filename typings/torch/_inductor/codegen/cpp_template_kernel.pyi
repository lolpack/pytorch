"""
This type stub file was generated by pyright.
"""

import sympy
from typing import Any, Callable, Optional, Union
from .. import ir
from ..autotune_process import CppBenchmarkRequest
from .cpp import CppKernel

def parse_expr_with_index_symbols(expr): # -> Expr | list[Expr | list[Any] | Any] | Any:
    ...

def wrap_with_tensorbox(node) -> ir.TensorBox:
    ...

class CppTemplateKernel(CppKernel):
    def __init__(self, kernel_name, num_threads) -> None:
        ...
    
    def render(self, template, **kwargs): # -> str:
        ...
    
    def def_kernel(self, inputs: dict[str, ir.Buffer], outputs: dict[str, ir.Buffer], aliases: Optional[dict[str, str]] = ..., function_name: str = ..., extra_sizevars: Optional[list[sympy.Expr]] = ..., placeholder: str = ...) -> str:
        ...
    
    def call_kernel(self, name: str, node: ir.CppTemplateBuffer): # -> None:
        ...
    
    def dtype(self, node: ir.Buffer) -> str:
        ...
    
    def acc_dtype(self, node: ir.Buffer) -> str:
        ...
    
    def size(self, node: ir.Buffer, dim: int) -> str:
        ...
    
    def stride(self, node: ir.Buffer, dim: int) -> str:
        ...
    
    def index(self, node: ir.Buffer, indices: list[Any]) -> str:
        ...
    
    def slice_nd(self, node, ranges: list[tuple[Any, Any]]) -> ir.ReinterpretView:
        """
        Slice the given node with a list of ranges (start and end) corresponding to its dims.
        The dim is not sliced if the corresponding range is empty.
        """
        ...
    
    def select(self, node, dim: int, idx: int) -> ir.ReinterpretView:
        ...
    
    def view(self, node, sizes: list[Any]) -> ir.View:
        ...
    
    def permute(self, node, dims): # -> ReinterpretView:
        ...
    
    def maybe_codegen_profile(self) -> str:
        ...
    
    def unroll_pragma(self, unroll): # -> str:
        ...
    
    def define_buffer(self, name, sizes: list[Any], dtype=...) -> str:
        """Define kernel local buffer"""
        ...
    
    def define_stack_allocated_buffer(self, name, sizes: list[Any], dtype=...) -> str:
        """Define stack-allocated buffer"""
        ...
    
    def reinit_buffer_if_null(self, name): # -> str:
        """Reinit the previously defined local buffer if it is null"""
        ...
    
    def release_buffer(self, name): # -> str:
        """Codegen the code to release the ownership of a local buffer to others"""
        ...
    
    def store_pointwise_nodes(self, dst: ir.Buffer, nodes: list[ir.IRNode], offsets: Optional[list[sympy.Expr]] = ..., reindexers: Optional[list[Optional[Callable[[list[Any]], list[Any]]]]] = ...) -> str:
        ...
    
    def store_grouped_gemm_pointwise_nodes(self, dst: tuple[ir.Buffer], nodes: list[ir.IRNode], offsets: list[sympy.Expr], reindexers: list[Optional[Callable[[list[Any]], list[Any]]]], output_names: list[str]) -> str:
        ...
    
    def store_output(self, dst: ir.Buffer, src: ir.Buffer, orig_src: Optional[ir.Buffer] = ..., epilogue_nodes: Optional[list[ir.IRNode]] = ..., offsets: Optional[list[Any]] = ..., reindexers: Optional[list[Optional[Callable[[list[Any]], list[Any]]]]] = ...): # -> str:
        """
        Store the `src` buffer to the `dst` buffer. The size of `src` and `dst` should match.
        If `epilogue_nodes` is provided, the `src` buffer is firstly computed with the epilogues
        before stored to `dst`. The `epilogues_nodes` are all pointwise.

        Notes:
        1. `src` and `dst` buffer could be the same buffer in which case we are doing in-place compute
           and stores. In case `epilogue_nodes` are not provided, we do nothing.
        2. The `epilogue_nodes`, if exist, have computations on `src` before storing to `dst` but since
           they come form the original Inductor IR, they might need to be adjusted before working with
           `src` and `dst` as outlined below:
           a) `src` or `dst` buffer could be a sub-slice of the ranges the `epilogue_nodes`work on.
              In this case, the `offsets` could be provided to adjust the indices passed to
              `epilogue_nodes` during codegen and the data ranges are also configured according to
              the sizes of `src` and `dst`.
           b) `dst` might be indexed in a different way as the `epilogue_nodes`, hence a `reindexer` is
              needed on the indices to `epilogue_nodes` to match the indexing of `dst`.
           c) If `src` is local, we need to add a local buffer for it and localize the `orig_src` buffer
              in `epilogue_nodes` with `src`.
        """
        ...
    
    def store_outputs(self, dst: tuple[ir.Buffer], src: tuple[ir.IRNode], orig_src: Optional[tuple[ir.IRNode]] = ..., epilogue_nodes: Optional[list[ir.IRNode]] = ..., offsets: Optional[list[Any]] = ..., reindexers: Optional[list[Optional[Callable[[list[Any]], list[Any]]]]] = ..., multi_output_buffers: Optional[tuple[ir.MultiOutput]] = ...): # -> str:
        ...
    
    def check_bounds(self, expr, size, lower, upper): # -> None:
        ...
    


class CppTemplateCaller(ir.ChoiceCaller):
    """
    CppTemplateCaller

    This class represents a caller for CPP template kernels. It is a subclass of ir.ChoiceCaller.
    Attributes:
        name (str): The name of the caller.
        category (str): The category of the caller.
        bmreq (CppBenchmarkRequest): The benchmark request for the caller.
        template_buffer (ir.CppTemplateBuffer): The template buffer for the caller.
    """
    def __init__(self, name: str, category: str, input_nodes: list[ir.Buffer], layout: ir.Layout, make_kernel_render: Callable[[ir.CppTemplateBuffer, bool, Optional[list[ir.IRNode]]], str,], bmreq: CppBenchmarkRequest, template: CppTemplate, info_kwargs: Optional[dict[str, Union[ir.PrimitiveInfoType, list[ir.PrimitiveInfoType]]]] = ...) -> None:
        ...
    
    def precompile(self) -> None:
        ...
    
    def benchmark(self, *args, out) -> float:
        ...
    
    def hash_key(self) -> str:
        ...
    
    def info_dict(self) -> dict[str, Union[ir.PrimitiveInfoType, list[ir.PrimitiveInfoType]]]:
        ...
    
    def output_node(self) -> ir.TensorBox:
        ...
    


