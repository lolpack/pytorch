"""
This type stub file was generated by pyright.
"""

import dataclasses
import sympy
import torch
from typing import Any, Optional, Protocol, TYPE_CHECKING
from ..utils import CachedMethod, IndentedBuffer, cache_on_self
from .wrapper import BufferLike, MemoryPlanningLine
from collections.abc import Iterable

if TYPE_CHECKING:
    ...
@dataclasses.dataclass
class LiveRange:
    """
    A range where a given tensor is live.  Begin and end are both counters
    representing points in the program of grouped memory operations.
    Begin is inclusive, end is exclusive.

    Invariant: begin <= end
    """
    begin: float
    end: float
    def contains(self, other: LiveRange): # -> bool:
        """Is other entirely within self"""
        ...
    
    def join(self, other: LiveRange): # -> LiveRange:
        """Combine two ranges using a union operation"""
        ...
    
    def __len__(self): # -> float:
        ...
    


class LiveRanges:
    """
    A collection of LiveRange regions, allowing for non-contiguous
    live regions.

    Invariant: LiveRanges.ranges is in sorted order and non-overlapping
    """
    def __init__(self, ranges: Iterable[LiveRange]) -> None:
        ...
    
    def overlaps(self, other: LiveRanges): # -> bool:
        """Check if any pair of ranges in self and other overlap"""
        ...
    
    @property
    def begin(self): # -> float:
        ...
    
    @property
    def end(self): # -> float:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class AllocationTreeNode:
    """
    Abstract base class for nodes in allocation pool.
    """
    def allocate(self, block: Allocation, is_last: bool) -> bool:
        """
        Try to assign block to a memory location in this bool.  Return True if
        an assignment was made.
        """
        ...
    
    def get_live_ranges(self) -> LiveRanges:
        """Aggregate LiveRanges for all objects below this in tree"""
        ...
    
    def get_size_hint(self) -> int:
        """Number of bytes used for example inputs"""
        ...
    
    def get_symbolic_size(self) -> sympy.Expr:
        """Number of bytes needed at runtime"""
        ...
    
    def finalize(self, pool, offset) -> AllocationTreeNode:
        """Called after all allocations have been made"""
        ...
    
    def is_empty(self): # -> Literal[False]:
        ...
    


@dataclasses.dataclass
class Allocation(AllocationTreeNode):
    """
    Represents memory allocated to a given node in the allocation pool.
    """
    node: BufferLike
    live_range: LiveRange
    size_hint: int
    symbolic_size: sympy.Expr
    allocated: bool = ...
    pool: Optional[AllocationPool] = ...
    offset: Optional[sympy.Expr] = ...
    @property
    def device(self): # -> BufferLike:
        ...
    
    def get_live_ranges(self): # -> LiveRanges:
        ...
    
    def get_size_hint(self): # -> int:
        ...
    
    def get_symbolic_size(self): # -> Expr:
        ...
    
    def mark_allocated(self): # -> None:
        ...
    
    def finalize(self, pool, offset): # -> Self:
        ...
    
    def codegen_alloc_from_pool(self, wrapper):
        ...
    
    def __repr__(self): # -> str:
        ...
    


@dataclasses.dataclass
class Empty(AllocationTreeNode):
    """
    Placeholder to represent empty space in the allocation pool.
    Only exists to get the size_hint correct in parent nodes.
    """
    size_hint: int
    def get_live_ranges(self): # -> LiveRanges:
        ...
    
    def get_size_hint(self): # -> int:
        ...
    
    def get_symbolic_size(self): # -> Literal[0]:
        ...
    
    def is_empty(self): # -> Literal[True]:
        ...
    


class MemorySplitProtocol(Protocol):
    get_live_ranges: CachedMethod[[], LiveRanges]
    get_size_hint: CachedMethod[[], int]
    get_symbolic_size: CachedMethod[[], sympy.Expr]
    ...


class ClearCacheOnAllocateMixin(MemorySplitProtocol):
    """
    Helper to assist in caching get_live_ranges, get_size_hint, and
    get_symbolic_size.
    """
    def allocate(self, block: Allocation, is_last: bool): # -> bool:
        ...
    
    def clear_cache(self): # -> None:
        ...
    


@dataclasses.dataclass
class TemporalSplit(ClearCacheOnAllocateMixin, AllocationTreeNode):
    """
    Contains a list of allocations not overlapping in LiveRanges.

    Invariant: no pair (a,b) in self.allocations will have:
         a.get_live_ranges().overlaps(b.get_live_ranges())
    """
    allocations: list[AllocationTreeNode]
    @cache_on_self
    def get_live_ranges(self) -> LiveRanges:
        ...
    
    @cache_on_self
    def get_size_hint(self) -> int:
        ...
    
    @cache_on_self
    def get_symbolic_size(self) -> sympy.Expr:
        ...
    
    def is_empty(self): # -> Literal[False]:
        ...
    
    def finalize(self, pool, offset): # -> AllocationTreeNode | Self:
        ...
    


@dataclasses.dataclass
class SpatialSplit(ClearCacheOnAllocateMixin, AllocationTreeNode):
    """
    Contains two allocations, left and right, that do not overlap in space.
    Right will be allocated immediately after left in memory.
    """
    left: TemporalSplit
    right: TemporalSplit
    @staticmethod
    def create(left, extra_space): # -> SpatialSplit:
        ...
    
    @cache_on_self
    def get_live_ranges(self): # -> LiveRanges:
        ...
    
    @cache_on_self
    def get_size_hint(self) -> int:
        ...
    
    @cache_on_self
    def get_symbolic_size(self) -> sympy.Expr:
        ...
    
    def finalize(self, pool, offset): # -> TemporalSplit | Self:
        ...
    


@dataclasses.dataclass
class AllocationPool:
    """
    Represents a pool of allocations that will be generated by a single
    call to torch.empty.
    """
    device: torch.device
    root: TemporalSplit
    can_expand: bool = ...
    restrict_live_range: Optional[LiveRange] = ...
    name: Optional[str] = ...
    names_to_del: list[str] = ...
    creation_cache: dict[str, str] = ...
    def allocate(self, block: Allocation, is_last: bool): # -> bool:
        ...
    
    def allocate_at_end(self, block): # -> Literal[True]:
        ...
    
    def finalize(self, name): # -> None:
        ...
    
    def codegen_create(self, wrapper, code: IndentedBuffer): # -> None:
        ...
    
    def codegen_destroy(self, wrapper, code: IndentedBuffer): # -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


@dataclasses.dataclass
class AllocationPools:
    """
    Collection of many AllocationPool objects grouped by device.
    """
    device_to_pools: dict[torch.device, list[AllocationPool]] = ...
    def get_pools(self, block): # -> list[AllocationPool]:
        ...
    
    def allocate(self, block: Allocation): # -> None:
        ...
    
    def allocate_output(self, block: Allocation): # -> None:
        """Outputs get different pools so memory gets freed properly"""
        ...
    
    def finalize(self): # -> None:
        """Called at the end of allocation process"""
        ...
    
    def pprint(self): # -> None:
        ...
    


class BufferGroup:
    """
    Due to inplace reuse an allocated buffer can have many names.
    This tracks these collections of buffers sharing underlying memory.
    """
    def __init__(self, node: BufferLike) -> None:
        ...
    
    def update_usage(self, timestep: int): # -> None:
        """Expand self.live_range to include timestep"""
        ...
    
    def sym_nbytes(self): # -> Any:
        ...
    
    def make_allocation(self): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


@dataclasses.dataclass
class PoolMemoryPlanningLine(MemoryPlanningLine):
    """Abstract base class for {Alloc,Dealloc}FromPoolLine"""
    group: BufferGroup
    timestep: Optional[int] = ...
    @property
    def node(self): # -> BufferLike:
        ...
    


@dataclasses.dataclass
class AllocFromPoolLine(PoolMemoryPlanningLine):
    """Similar to AllocationLine, but takes memory from a pool"""
    is_first_pool_usage: bool = ...
    def codegen(self, code: IndentedBuffer): # -> None:
        ...
    


@dataclasses.dataclass
class DeallocFromPoolLine(PoolMemoryPlanningLine):
    """Similar to FreeIfNotReusedLine, but takes memory from a pool"""
    is_last_pool_usage: bool = ...
    def codegen(self, code: IndentedBuffer): # -> None:
        ...
    


@dataclasses.dataclass
class MemoryPlanner:
    """
    Coordination object to run memory planning passes during wrapper
    codegen.
    """
    wrapper: Any
    pools: AllocationPools = ...
    buffer_groups: Optional[list[BufferGroup]] = ...
    def plan(self, lines: list[Any]) -> list[Any]:
        """Call all the memory planning passes in sequence"""
        ...
    
    def drop_removed_buffers(self, lines): # -> None:
        """
        Replace any memory planning lines in V.graph.removed_buffers with NullLine
        """
        ...
    
    def compute_buffer_groups(self, lines): # -> dict[Any, Any]:
        """
        Populates self.buffer_groups with BufferGroup objects that join
        allocations with common storage (due to inplace reuse) into a
        single object.
        """
        ...
    
    def convert_to_pool_lines(self, lines): # -> None:
        """
        Convert AllocateLine/FreeIfNotReusedLine/ReuseLine into their
        pool-based counterparts.
        """
        ...
    
    def compute_live_ranges(self, lines): # -> None:
        """Populate every BufferGroup.live_ranges field based on first/last usage"""
        ...
    
    def allocate_groups(self): # -> None:
        """
        Assign every allocation to a specific location in a specific AllocationPool.
        """
        ...
    
    def mark_first_last_usage(self, lines): # -> None:
        """
        Populate the AllocFromPoolLine.is_first_pool_usage and
        DeallocFromPoolLine.is_last_pool_usage fields so that pools
        are created/destroyed.
        """
        ...
    


