"""
This type stub file was generated by pyright.
"""

import sympy
import torch
from typing import Any, Optional, TYPE_CHECKING, Union
from torch.utils._ordered_set import OrderedSet
from torch.utils._sympy.printers import ExprPrinter as ExprPrinter_
from .common import CSEVariable, OpOverrides, OpVarT
from .simd import IterationRangesEntry, SIMDKernel, SIMDScheduling
from ..ops_handler import ReductionType, StoreMode
from ..scheduler import Scheduler, SchedulerNode

if TYPE_CHECKING:
    ...
log = ...
DTYPE_TO_METAL = ...
def value_to_metal(val: Union[float, int, bool, str, CSEVariable]) -> str:
    ...

class MetalExprPrinter(ExprPrinter_):
    """Converts sympy expression to Metal code snippet"""
    _print_floor = ...


class MetalOverrides(OpOverrides):
    """Implements Metal-specific overrides for ops. Base class emits Python-friendly overrides."""
    @staticmethod
    def to_dtype(x: CSEVariable, dtype: torch.dtype, src_dtype: Optional[torch.dtype] = ..., use_compute_types: bool = ...) -> str:
        ...
    
    @staticmethod
    def to_dtype_bitcast(x: CSEVariable, dtype: torch.dtype, src_dtype: torch.dtype) -> str:
        ...
    
    @staticmethod
    def constant(val: Union[bool, float, int], dtype: torch.dtype) -> str:
        ...
    
    @staticmethod
    def index_expr(expr: sympy.Expr, dtype: torch.dtype) -> str:
        ...
    
    @staticmethod
    def masked(mask: CSEVariable, body: sympy.Expr, other: CSEVariable) -> str:
        ...
    
    @staticmethod
    def where(a: OpVarT, b: OpVarT, c: OpVarT) -> str:
        ...
    
    @staticmethod
    def remainder(a: OpVarT, b: OpVarT) -> str:
        ...
    
    @staticmethod
    def maximum(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def minimum(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def logical_or(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def logical_and(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def isnan(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def isinf(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def log(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def exp(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def abs(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def signbit(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def sin(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def sinc(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def cos(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def tan(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def asin(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def acos(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def atan(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def atan2(x: CSEVariable, y: CSEVariable) -> str:
        ...
    
    @staticmethod
    def sqrt(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def neg(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def rsqrt(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def tanh(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def atanh(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def floordiv(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def floor(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def sign(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def fmod(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def trunc(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def truncdiv(a: CSEVariable, b: CSEVariable) -> str:
        ...
    
    @staticmethod
    def ceil(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def rand(seed: CSEVariable, offset: CSEVariable) -> str:
        ...
    
    @staticmethod
    def randn(seed: CSEVariable, offset: CSEVariable) -> str:
        ...
    
    @staticmethod
    def randint64(seed: CSEVariable, offset: CSEVariable, low: CSEVariable, high: CSEVariable) -> str:
        ...
    
    @staticmethod
    def round(x: CSEVariable) -> str:
        ...
    
    @staticmethod
    def pow(a: CSEVariable, b: CSEVariable) -> str:
        ...
    


class MetalKernel(SIMDKernel):
    """Implement Metal codegen based on the SIMDKernel abstraction"""
    overrides = MetalOverrides
    suffix = ...
    newvar_prefix = ...
    max_threadgroup_size = ...
    simd_group_size = ...
    pexpr = ...
    cexpr = ...
    sexpr = ...
    kexpr = ...
    headers: OrderedSet[str] = ...
    multistage_reduction_entry: list[IterationRangesEntry] = ...
    def __init__(self, tiling: dict[str, sympy.Expr], **kwargs: Any) -> None:
        ...
    
    def dtype_to_str(self, dtype: torch.dtype) -> str:
        ...
    
    def load(self, name: str, index: sympy.Expr) -> CSEVariable:
        """Codegen a load from an InputBuffer"""
        ...
    
    def store(self, name: str, index: sympy.Expr, value: CSEVariable, mode: StoreMode = ...) -> None:
        ...
    
    def store_reduction(self, name: str, index: sympy.Expr, value: CSEVariable) -> None:
        ...
    
    def reduction(self, dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: ReductionType, value: Union[CSEVariable, tuple[CSEVariable, ...]]) -> Union[CSEVariable, tuple[CSEVariable, ...]]:
        "Caching wrapper around _reduction_nocache"
        ...
    
    def codegen_iteration_ranges_entry(self, entry: IterationRangesEntry) -> None:
        ...
    
    def codegen_body(self) -> None:
        """
        Concat output code from index_code, loads, compute, stores,
        suffix into self.body.

        For pointwise kernels, this is called just once at the end.

        For reduction kernels, this generates a loop over the reduction
        axis.
        """
        ...
    
    def codegen_kernel(self, name: Optional[str] = ...) -> str:
        """Called at the end to generate a final kernel string"""
        ...
    
    def call_kernel(self, name: str, node: Any = ...) -> None:
        """Codegen a call to this kernel"""
        ...
    
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None:
        ...
    


class MetalScheduling(SIMDScheduling):
    kernel_type = ...
    def __init__(self, scheduler: Optional[Scheduler]) -> None:
        ...
    
    def define_kernel(self, src_code: str, node_schedule: list[SchedulerNode], kernel: MetalKernel) -> str:
        ...
    


