"""
This type stub file was generated by pyright.
"""

import dataclasses
import onnx
from collections.abc import Iterator, Mapping, Sequence
from typing import Any
from onnxscript import ir

logger = ...
class _Empty:
    def __repr__(self): # -> Literal['_EMPTY_DEFAULT']:
        ...
    


_EMPTY_DEFAULT = ...
_PY_TYPE_TO_ATTR_TYPE = ...
_LIST_TYPE_TO_ATTR_TYPE = ...
_ALL_VALUE_TYPES = ...
TypeAnnotationValue = Any
@dataclasses.dataclass(frozen=True)
class TypeConstraintParam:
    """Type constraint for a parameter.

    Attributes:
        name: Name of the parameter. E.g. "TFloat"
        allowed_types: Allowed types for the parameter.
    """
    name: str
    allowed_types: set[ir.TypeProtocol]
    description: str = ...
    def __hash__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    @classmethod
    def any_tensor(cls, name: str, description: str = ...) -> TypeConstraintParam:
        ...
    
    @classmethod
    def any_value(cls, name: str, description: str = ...) -> TypeConstraintParam:
        ...
    


@dataclasses.dataclass(frozen=True)
class Parameter:
    """A formal parameter of an operator."""
    name: str
    type_constraint: TypeConstraintParam
    required: bool
    variadic: bool
    default: Any = ...
    def __str__(self) -> str:
        ...
    
    def has_default(self) -> bool:
        ...
    


@dataclasses.dataclass(frozen=True)
class AttributeParameter:
    """A parameter in the function signature that represents an ONNX attribute."""
    name: str
    type: ir.AttributeType
    required: bool
    default: ir.Attr | None = ...
    def __str__(self) -> str:
        ...
    
    def has_default(self) -> bool:
        ...
    


@dataclasses.dataclass
class OpSignature:
    """Schema for an operator.

    Attributes:
        domain: Domain of the operator. E.g. "".
        name: Name of the operator. E.g. "Add".
        overload: Overload name of the operator.
        params: Input parameters. When the op is an ONNX function definition,
          the order is according to the function signature. This mean we can
          interleave ONNX inputs and ONNX attributes in the list.
        outputs: Output parameters.
    """
    domain: str
    name: str
    overload: str
    params: Sequence[Parameter | AttributeParameter]
    outputs: Sequence[Parameter]
    params_map: Mapping[str, Parameter | AttributeParameter] = ...
    opset_version: int | None = ...
    def __post_init__(self): # -> None:
        ...
    
    def get(self, name: str) -> Parameter | AttributeParameter:
        ...
    
    def __contains__(self, name: str) -> bool:
        ...
    
    def __iter__(self) -> Iterator[Parameter | AttributeParameter]:
        ...
    
    def __str__(self) -> str:
        ...
    
    @classmethod
    def from_opschema(cls, opschema: onnx.defs.OpSchema) -> OpSignature:
        """Produce an OpSignature from an ONNX Opschema."""
        ...
    
    @classmethod
    def from_function(cls, func, domain: str, name: str | None = ..., overload: str = ..., *, opset_version: int = ...) -> OpSignature:
        """Produce an OpSignature from a function using type annotation."""
        ...
    


