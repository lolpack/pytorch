"""
This type stub file was generated by pyright.
"""

import dataclasses
import functools
import sympy
from typing import Callable, Generic, Optional, TYPE_CHECKING, TypeVar, Union, overload
from typing_extensions import TypeGuard
from sympy.logic.boolalg import Boolean as SympyBoolean

log = ...
__all__ = ["ValueRanges", "bound_sympy"]
_T = TypeVar("_T", sympy.Expr, SympyBoolean)
class ValueRangeError(RuntimeError):
    ...


def simple_sympify(e): # -> BooleanTrue | BooleanFalse | One | NegativeOne | Zero | Integer | Infinity | NegativeInfinity | Float | Expr | BooleanAtom:
    ...

def sympy_generic_le(lower, upper): # -> _NotImplementedType | GreaterThan | Equality | Relational | Unequality | Integer | bool:
    ...

def vr_is_bool(vr: ValueRanges[_T]) -> TypeGuard[ValueRanges[SympyBoolean]]:
    ...

def vr_is_expr(vr: ValueRanges[_T]) -> TypeGuard[ValueRanges[sympy.Expr]]:
    ...

ExprIn = Union[int, float, sympy.Expr]
BoolIn = Union[bool, SympyBoolean]
AllIn = Union[ExprIn, BoolIn]
ExprFn = Callable[[sympy.Expr], sympy.Expr]
ExprFn2 = Callable[[sympy.Expr, sympy.Expr], sympy.Expr]
BoolFn = Callable[[SympyBoolean], SympyBoolean]
BoolFn2 = Callable[[SympyBoolean, SympyBoolean], SympyBoolean]
AllFn = Union[ExprFn, BoolFn]
AllFn2 = Union[ExprFn2, BoolFn2]
@dataclasses.dataclass(frozen=True)
class ValueRanges(Generic[_T]):
    if TYPE_CHECKING:
        ExprVR = ...
        BoolVR = ...
        AllVR = Union[ExprVR, BoolVR]
    lower: _T
    upper: _T
    is_bool: bool
    is_int: bool
    is_float: bool
    def __repr__(self) -> str:
        ...
    
    @overload
    def __init__(self: ValueRanges[sympy.Expr], lower: ExprIn, upper: ExprIn) -> None:
        ...
    
    @overload
    def __init__(self: ValueRanges[SympyBoolean], lower: BoolIn, upper: BoolIn) -> None:
        ...
    
    def __init__(self, lower: AllIn, upper: AllIn) -> None:
        ...
    
    def boolify(self) -> ValueRanges[SympyBoolean]:
        ...
    
    def __contains__(self, x: AllIn) -> bool:
        ...
    
    def issubset(self, other): # -> _NotImplementedType | GreaterThan | Equality | Relational | Unequality | Integer | bool:
        ...
    
    def tighten(self, other) -> ValueRanges:
        """Given two ValueRanges, returns their intersection"""
        ...
    
    @overload
    def __and__(self: ValueRanges[sympy.Expr], other: ValueRanges[sympy.Expr]) -> ValueRanges[sympy.Expr]:
        ...
    
    @overload
    def __and__(self: ValueRanges[SympyBoolean], other: ValueRanges[SympyBoolean]) -> ValueRanges[SympyBoolean]:
        ...
    
    def __and__(self: AllVR, other: AllVR) -> AllVR:
        ...
    
    @overload
    def __or__(self: ValueRanges[sympy.Expr], other: ValueRanges[sympy.Expr]) -> ValueRanges[sympy.Expr]:
        ...
    
    @overload
    def __or__(self: ValueRanges[SympyBoolean], other: ValueRanges[SympyBoolean]) -> ValueRanges[SympyBoolean]:
        ...
    
    def __or__(self: AllVR, other: AllVR) -> AllVR:
        ...
    
    def is_singleton(self) -> bool:
        ...
    
    @staticmethod
    @functools.cache
    def unknown() -> ValueRanges[sympy.Expr]:
        ...
    
    @staticmethod
    @functools.cache
    def unknown_int() -> ValueRanges[sympy.Expr]:
        ...
    
    @staticmethod
    @functools.cache
    def unknown_bool() -> ValueRanges[SympyBoolean]:
        ...
    
    @overload
    @staticmethod
    def wrap(arg: Union[ExprIn, ExprVR]) -> ExprVR:
        ...
    
    @overload
    @staticmethod
    def wrap(arg: Union[BoolIn, BoolVR]) -> BoolVR:
        ...
    
    @staticmethod
    def wrap(arg: Union[AllIn, AllVR]) -> AllVR:
        ...
    
    @staticmethod
    def increasing_map(x: Union[ExprIn, ExprVR], fn: ExprFn) -> ExprVR:
        """Increasing: x <= y => f(x) <= f(y)."""
        ...
    
    @overload
    @staticmethod
    def decreasing_map(x: Union[ExprIn, ExprVR], fn: ExprFn) -> ExprVR:
        ...
    
    @overload
    @staticmethod
    def decreasing_map(x: Union[BoolIn, BoolVR], fn: BoolFn) -> BoolVR:
        ...
    
    @staticmethod
    def decreasing_map(x: Union[AllIn, AllVR], fn: AllFn) -> AllVR:
        """Decreasing: x <= y => f(x) >= f(y)."""
        ...
    
    @staticmethod
    def monotone_map(x: Union[ExprIn, ExprVR], fn: ExprFn) -> ExprVR:
        """It's increasing or decreasing."""
        ...
    
    @staticmethod
    def convex_min_zero_map(x: Union[ExprIn, ExprVR], fn: ExprFn) -> ExprVR:
        """Fn is convex and has a minimum at 0."""
        ...
    
    @overload
    @staticmethod
    def coordinatewise_increasing_map(x: Union[ExprIn, ExprVR], y: Union[ExprIn, ExprVR], fn: ExprFn2) -> ExprVR:
        ...
    
    @overload
    @staticmethod
    def coordinatewise_increasing_map(x: Union[BoolIn, BoolVR], y: Union[BoolIn, BoolVR], fn: BoolFn2) -> BoolVR:
        ...
    
    @staticmethod
    def coordinatewise_increasing_map(x: Union[AllIn, AllVR], y: Union[AllIn, AllVR], fn: AllFn2) -> AllVR:
        """
        It's increasing on each coordinate.

        Mathematically:
        For every 1 <= i <= n and x_i <= y_i we have that
        f(x1, .., xn) <= f(x1, , yi, ..., xn)
        """
        ...
    
    @classmethod
    def coordinatewise_monotone_map(cls, x, y, fn): # -> ValueRanges[Expr]:
        """It's increasing or decreasing on each coordinate."""
        ...
    


class SymPyValueRangeAnalysis:
    """
    It gives bounds on a SymPy operator given bounds on its arguments
    See the function `bound_sympy` for a function that applies this logic to a full SymPy expression
    """
    @staticmethod
    def constant(value, dtype): # -> ValueRanges[Boolean] | ValueRanges[Expr]:
        ...
    
    @staticmethod
    def to_dtype(a, dtype, src_dtype=...): # -> ValueRanges[Boolean] | ValueRanges[Expr]:
        ...
    
    @staticmethod
    def trunc_to_int(a, dtype):
        ...
    
    @staticmethod
    def not_(a):
        ...
    
    @staticmethod
    def or_(a, b):
        ...
    
    @staticmethod
    def and_(a, b):
        ...
    
    @classmethod
    def bitwise_and(cls, a, b): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def bitwise_or(cls, a, b): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def eq(a, b): # -> ValueRanges[Boolean]:
        ...
    
    @classmethod
    def ne(cls, a, b):
        ...
    
    @classmethod
    def identity(cls, a):
        ...
    
    @classmethod
    def lt(cls, a, b): # -> ValueRanges[Boolean]:
        ...
    
    @classmethod
    def gt(cls, a, b): # -> ValueRanges[Boolean]:
        ...
    
    @classmethod
    def le(cls, a, b):
        ...
    
    @classmethod
    def ge(cls, a, b):
        ...
    
    @staticmethod
    def add(a, b):
        ...
    
    @classmethod
    def mul(cls, a, b): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def int_truediv(a, b): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def truediv(a, b): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def floordiv(a, b): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def mod(cls, x, y): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def modular_indexing(cls, a, b, c): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def is_non_overlapping_and_dense_indicator(cls, *args): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def pow_by_natural(cls, a, b): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def pow(cls, a, b): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def reciprocal(x): # -> ValueRanges[Expr]:
        """Needed as it's used in pow, but it won't appear on a SymPy expression"""
        ...
    
    @staticmethod
    def abs(x):
        ...
    
    @staticmethod
    def exp(x):
        ...
    
    @staticmethod
    def log(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def log2(x): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def minimum(cls, a, b):
        ...
    
    @classmethod
    def maximum(cls, a, b):
        ...
    
    @staticmethod
    def min_or_max(a, b, fn):
        ...
    
    @classmethod
    def floor_to_int(cls, x, dtype):
        ...
    
    @classmethod
    def ceil_to_int(cls, x, dtype):
        ...
    
    @classmethod
    def floor(cls, x):
        ...
    
    @classmethod
    def ceil(cls, x):
        ...
    
    @classmethod
    def round_decimal(cls, number, ndigits): # -> ValueRanges[Expr]:
        ...
    
    @classmethod
    def round_to_int(cls, number, dtype):
        ...
    
    @staticmethod
    def sqrt(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def where(a, b, c): # -> ValueRanges[Boolean] | ValueRanges[Expr]:
        ...
    
    @staticmethod
    def expr_cond_pair(a, b): # -> tuple[Any, Any]:
        ...
    
    @staticmethod
    def piecewise(*ranges): # -> None:
        ...
    
    @staticmethod
    def cos(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def cosh(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def sin(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def sinh(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def tan(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def tanh(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def asin(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def acos(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def atan(x): # -> ValueRanges[Expr]:
        ...
    
    @staticmethod
    def trunc(x):
        ...
    


def bound_sympy(expr: sympy.Expr, ranges: Optional[dict[sympy.Symbol, ValueRanges]] = ...) -> ValueRanges:
    ...

