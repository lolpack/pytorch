"""
This type stub file was generated by pyright.
"""

import sympy
from typing import Optional, SupportsFloat, TYPE_CHECKING, TypeVar, Union
from typing_extensions import TypeVarTuple
from sympy.core.expr import Expr
from sympy.core.function import Application
from sympy.core.operations import LatticeOp

if TYPE_CHECKING:
    ...
_T = TypeVar("_T", bound=SupportsFloat)
_Ts = TypeVarTuple("_Ts")
__all__ = ["FloorDiv", "ModularIndexing", "Where", "PythonMod", "Mod", "CleanDiv", "CeilToInt", "FloorToInt", "CeilDiv", "IntTrueDiv", "FloatTrueDiv", "LShift", "RShift", "IsNonOverlappingAndDenseIndicator", "TruncToFloat", "TruncToInt", "RoundToInt", "RoundDecimal", "ToFloat", "FloatPow", "PowByNatural", "Identity"]
def fuzzy_eq(x: Optional[bool], y: Optional[bool]) -> Optional[bool]:
    ...

def simple_floordiv_gcd(p: sympy.Basic, q: sympy.Basic) -> sympy.Basic:
    """
    Fast path for sympy.gcd, using a simple factoring strategy.

    We try to rewrite p and q in the form n*e*p1 + n*e*p2 and n*e*q0,
    where n is the greatest common integer factor and e is the largest
    syntactic common factor (i.e., common sub-expression) in p and q.
    Then the gcd returned is n*e, cancelling which we would be left with
    p1 + p2 and q0.

    Note that further factoring of p1 + p2 and q0 might be possible with
    sympy.factor (which uses domain-specific theories). E.g., we are unable
    to find that x*y + x + y + 1 is divisible by x + 1. More generally,
    when q is of the form q1 + q2 (instead of being already factored) it
    might be necessary to fall back on sympy.gcd.
    """
    ...

class FloorDiv(sympy.Function):
    """
    We maintain this so that:
    1. We can use divisibility guards to simplify FloorDiv(a, b) to a / b.
    2. Printing out the expression is nicer (compared to say, representing a//b as (a - a % b) / b)

    NB: This is Python-style floor division, round to -Inf
    """
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @property
    def base(self) -> sympy.Basic:
        ...
    
    @property
    def divisor(self) -> sympy.Basic:
        ...
    
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer) -> Union[sympy.Basic, None]:
        ...
    


class ModularIndexing(sympy.Function):
    """
    ModularIndexing(a, b, c) => (a // b) % c where % is the C modulus
    """
    nargs: tuple[int, ...] = ...
    is_integer: bool = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer, modulus: sympy.Integer) -> Optional[sympy.Basic]:
        ...
    


class Where(sympy.Function):
    """
    Good ol' ternary operator
    """
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    @classmethod
    def eval(cls, c: sympy.Basic, p: sympy.Basic, q: sympy.Basic) -> Optional[sympy.Basic]:
        ...
    


class PythonMod(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @classmethod
    def eval(cls, p: sympy.Expr, q: sympy.Expr) -> Optional[sympy.Expr]:
        ...
    


class Mod(sympy.Function):
    nargs = ...
    precedence: int = ...
    is_integer = ...
    is_nonnegative = ...
    @classmethod
    def eval(cls, p, q): # -> Zero | One | None:
        ...
    


class CleanDiv(FloorDiv):
    """
    Div where we can assume no rounding.
    This is to enable future optimizations.
    """
    ...


class CeilToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): # -> One | NegativeOne | Zero | Integer | None:
        ...
    


class FloorToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): # -> Integer | One | NegativeOne | Zero | None:
        ...
    


class CeilDiv(sympy.Function):
    """
    Div used in indexing that rounds up.
    """
    is_integer = ...
    def __new__(cls, base, divisor): # -> type[AppliedUndef]:
        ...
    


class LShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift):
        ...
    


class RShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift): # -> type[AppliedUndef]:
        ...
    


class MinMaxBase(Expr, LatticeOp):
    def __new__(cls, *original_args, **assumptions): # -> int | Basic | Expr | Self:
        ...
    
    _eval_is_algebraic = ...
    _eval_is_antihermitian = ...
    _eval_is_commutative = ...
    _eval_is_complex = ...
    _eval_is_composite = ...
    _eval_is_even = ...
    _eval_is_finite = ...
    _eval_is_hermitian = ...
    _eval_is_imaginary = ...
    _eval_is_infinite = ...
    _eval_is_integer = ...
    _eval_is_irrational = ...
    _eval_is_negative = ...
    _eval_is_noninteger = ...
    _eval_is_nonnegative = ...
    _eval_is_nonpositive = ...
    _eval_is_nonzero = ...
    _eval_is_odd = ...
    _eval_is_polar = ...
    _eval_is_positive = ...
    _eval_is_prime = ...
    _eval_is_rational = ...
    _eval_is_real = ...
    _eval_is_extended_real = ...
    _eval_is_transcendental = ...
    _eval_is_zero = ...


class Max(MinMaxBase, Application):
    r"""
    Return, if possible, the maximum value of the list.
    """
    zero = ...
    identity = ...


class Min(MinMaxBase, Application):
    """
    Return, if possible, the minimum value of the list.
    """
    zero = ...
    identity = ...


def safe_pow(base, exp): # -> int:
    ...

class PowByNatural(sympy.Function):
    is_integer = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp): # -> int | One | NegativeOne | Zero | Integer | Expr | ComplexInfinity | None:
        ...
    


class FloatPow(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp): # -> Float | None:
        ...
    


class FloatTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor): # -> Float | None:
        ...
    


class IntTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor): # -> Float | None:
        ...
    


class IsNonOverlappingAndDenseIndicator(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, *args): # -> int | None:
        ...
    


class TruncToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number): # -> Float | None:
        ...
    


class TruncToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): # -> One | NegativeOne | Zero | Integer | None:
        ...
    


class RoundToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): # -> One | NegativeOne | Zero | Integer | None:
        ...
    


class RoundDecimal(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number, ndigits): # -> Float | None:
        ...
    


class ToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number): # -> Float | Infinity | NegativeInfinity | None:
        ...
    


class Identity(sympy.Function):
    """
    Prevents expansion and other optimizations
    """
    precedence = ...
    def __repr__(self): # -> str:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __float__(self) -> float:
        ...
    


def make_opaque_unary_fn(name): # -> type[OpaqueUnaryFn]:
    class OpaqueUnaryFn(sympy.Function):
        """
        Unlike the builtin sympy functions on real numbers like sympy.sqrt,
        these equivalents do not do any nontrivial reasoning besides
        constant propagation.  This helps avoid performing transformations
        that are valid for real numbers but are invalid for floating point;
        in particular, while we are willing to make optimizations that change
        numerics for Tensor compute, we are NOT willing to make optimziations
        that change numerics for size compute.
        """
        ...
    
    

OpaqueUnaryFn_sqrt = ...
OpaqueUnaryFn_cos = ...
OpaqueUnaryFn_cosh = ...
OpaqueUnaryFn_sin = ...
OpaqueUnaryFn_sinh = ...
OpaqueUnaryFn_tan = ...
OpaqueUnaryFn_tanh = ...
OpaqueUnaryFn_asin = ...
OpaqueUnaryFn_acos = ...
OpaqueUnaryFn_atan = ...
OpaqueUnaryFn_exp = ...
OpaqueUnaryFn_log = ...
OpaqueUnaryFn_asinh = ...
OpaqueUnaryFn_log2 = ...
def make_opaque_bitwise_fn(name, real_op_name): # -> type[BitwiseFn]:
    class BitwiseFn(sympy.Function):
        ...
    
    

BitwiseFn_bitwise_and = ...
BitwiseFn_bitwise_or = ...
