"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable
from io import IOBase
from typing import Any, Callable, Optional, Union

__all__ = ["validate_input_col", "StreamWrapper", "get_file_binaries_from_pathnames", "get_file_pathnames_from_root", "match_masks", "validate_pathname_binary_tuple"]
DILL_AVAILABLE = ...
def validate_input_col(fn: Callable, input_col: Optional[Union[int, tuple, list]]): # -> None:
    """
    Check that function used in a callable datapipe works with the input column.

    This simply ensures that the number of positional arguments matches the size
    of the input column. The function must not contain any non-default
    keyword-only arguments.

    Examples:
        >>> # xdoctest: +SKIP("Failing on some CI machines")
        >>> def f(a, b, *, c=1):
        >>>     return a + b + c
        >>> def f_def(a, b=1, *, c=1):
        >>>     return a + b + c
        >>> assert validate_input_col(f, [1, 2])
        >>> assert validate_input_col(f_def, 1)
        >>> assert validate_input_col(f_def, [1, 2])

    Notes:
        If the function contains variable positional (`inspect.VAR_POSITIONAL`) arguments,
        for example, f(a, *args), the validator will accept any size of input column
        greater than or equal to the number of positional arguments.
        (in this case, 1).

    Args:
        fn: The function to check.
        input_col: The input column to check.

    Raises:
        ValueError: If the function is not compatible with the input column.
    """
    ...

def match_masks(name: str, masks: Union[str, list[str]]) -> bool:
    ...

def get_file_pathnames_from_root(root: str, masks: Union[str, list[str]], recursive: bool = ..., abspath: bool = ..., non_deterministic: bool = ...) -> Iterable[str]:
    ...

def get_file_binaries_from_pathnames(pathnames: Iterable, mode: str, encoding: Optional[str] = ...): # -> Generator[tuple[str, StreamWrapper], Any, None]:
    ...

def validate_pathname_binary_tuple(data: tuple[str, IOBase]): # -> None:
    ...

_iter_deprecated_functional_names: dict[str, dict] = ...
_map_deprecated_functional_names: dict[str, dict] = ...
class StreamWrapper:
    """
    StreamWrapper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.

    StreamWrapper would guarantee the wrapped file handler is closed when it's out of scope.
    """
    session_streams: dict[Any, int] = ...
    debug_unclosed_streams: bool = ...
    def __init__(self, file_obj, parent_stream=..., name=...) -> None:
        ...
    
    @classmethod
    def close_streams(cls, v, depth=...): # -> None:
        """Traverse structure and attempts to close all found StreamWrappers on best effort basis."""
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def close(self, *args, **kwargs): # -> None:
        ...
    
    def autoclose(self): # -> None:
        """Automatically close stream when all child streams are closed or if there are none."""
        ...
    
    def __dir__(self): # -> list[str]:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def __next__(self):
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getstate__(self): # -> Any:
        ...
    
    def __setstate__(self, obj): # -> None:
        ...
    


