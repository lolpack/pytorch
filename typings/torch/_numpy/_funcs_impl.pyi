"""
This type stub file was generated by pyright.
"""

from typing import Optional, TYPE_CHECKING
from collections.abc import Sequence
from ._normalizations import ArrayLike, ArrayLikeOrScalar, CastingModes, DTypeLike, NDArray, NotImplementedType, OutArray

"""A thin pytorch / numpy compat layer.

Things imported from here have numpy-compatible signatures but operate on
pytorch tensors.
"""
if TYPE_CHECKING:
    ...
def copy(a: ArrayLike, order: NotImplementedType = ..., subok: NotImplementedType = ...):
    ...

def copyto(dst: NDArray, src: ArrayLike, casting: Optional[CastingModes] = ..., where: NotImplementedType = ...): # -> None:
    ...

def atleast_1d(*arys: ArrayLike): # -> list[Any] | Any:
    ...

def atleast_2d(*arys: ArrayLike): # -> list[Any] | Any:
    ...

def atleast_3d(*arys: ArrayLike): # -> list[Any] | Any:
    ...

def concatenate(ar_tuple: Sequence[ArrayLike], axis=..., out: Optional[OutArray] = ..., dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...): # -> Tensor:
    ...

def vstack(tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...): # -> Tensor:
    ...

row_stack = ...
def hstack(tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...): # -> Tensor:
    ...

def dstack(tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...): # -> Tensor:
    ...

def column_stack(tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...): # -> Tensor:
    ...

def stack(arrays: Sequence[ArrayLike], axis=..., out: Optional[OutArray] = ..., *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...):
    ...

def append(arr: ArrayLike, values: ArrayLike, axis=...): # -> Tensor:
    ...

def array_split(ary: ArrayLike, indices_or_sections, axis=...): # -> tuple[Tensor, ...]:
    ...

def split(ary: ArrayLike, indices_or_sections, axis=...): # -> tuple[Tensor, ...]:
    ...

def hsplit(ary: ArrayLike, indices_or_sections): # -> tuple[Tensor, ...]:
    ...

def vsplit(ary: ArrayLike, indices_or_sections): # -> tuple[Tensor, ...]:
    ...

def dsplit(ary: ArrayLike, indices_or_sections): # -> tuple[Tensor, ...]:
    ...

def kron(a: ArrayLike, b: ArrayLike): # -> Tensor:
    ...

def vander(x: ArrayLike, N=..., increasing=...): # -> Tensor:
    ...

def linspace(start: ArrayLike, stop: ArrayLike, num=..., endpoint=..., retstep=..., dtype: Optional[DTypeLike] = ..., axis=...):
    ...

def geomspace(start: ArrayLike, stop: ArrayLike, num=..., endpoint=..., dtype: Optional[DTypeLike] = ..., axis=...):
    ...

def logspace(start, stop, num=..., endpoint=..., base=..., dtype: Optional[DTypeLike] = ..., axis=...):
    ...

def arange(start: Optional[ArrayLikeOrScalar] = ..., stop: Optional[ArrayLikeOrScalar] = ..., step: Optional[ArrayLikeOrScalar] = ..., dtype: Optional[DTypeLike] = ..., *, like: NotImplementedType = ...):
    ...

def empty(shape, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...):
    ...

def empty_like(prototype: ArrayLike, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., subok: NotImplementedType = ..., shape=...): # -> Tensor:
    ...

def full(shape, fill_value: ArrayLike, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...):
    ...

def full_like(a: ArrayLike, fill_value, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., subok: NotImplementedType = ..., shape=...): # -> Tensor:
    ...

def ones(shape, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...):
    ...

def ones_like(a: ArrayLike, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., subok: NotImplementedType = ..., shape=...): # -> Tensor:
    ...

def zeros(shape, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...):
    ...

def zeros_like(a: ArrayLike, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., subok: NotImplementedType = ..., shape=...): # -> Tensor:
    ...

def corrcoef(x: ArrayLike, y: Optional[ArrayLike] = ..., rowvar=..., bias=..., ddof=..., *, dtype: Optional[DTypeLike] = ...): # -> Tensor:
    ...

def cov(m: ArrayLike, y: Optional[ArrayLike] = ..., rowvar=..., bias=..., ddof=..., fweights: Optional[ArrayLike] = ..., aweights: Optional[ArrayLike] = ..., *, dtype: Optional[DTypeLike] = ...): # -> Tensor:
    ...

def convolve(a: ArrayLike, v: ArrayLike, mode=...):
    ...

def correlate(a: ArrayLike, v: ArrayLike, mode=...):
    ...

def bincount(x: ArrayLike, /, weights: Optional[ArrayLike] = ..., minlength=...): # -> Tensor:
    ...

def where(condition: ArrayLike, x: Optional[ArrayLikeOrScalar] = ..., y: Optional[ArrayLikeOrScalar] = ..., /): # -> tuple[Tensor, ...]:
    ...

def ndim(a: ArrayLike):
    ...

def shape(a: ArrayLike): # -> tuple[Any, ...]:
    ...

def size(a: ArrayLike, axis=...):
    ...

def expand_dims(a: ArrayLike, axis):
    ...

def flip(m: ArrayLike, axis=...): # -> Tensor:
    ...

def flipud(m: ArrayLike): # -> Tensor:
    ...

def fliplr(m: ArrayLike): # -> Tensor:
    ...

def rot90(m: ArrayLike, k=..., axes=...): # -> Tensor:
    ...

def broadcast_to(array: ArrayLike, shape, subok: NotImplementedType = ...): # -> Tensor:
    ...

def broadcast_arrays(*args: ArrayLike, subok: NotImplementedType = ...): # -> Any:
    ...

def meshgrid(*xi: ArrayLike, copy=..., sparse=..., indexing=...): # -> list[Any]:
    ...

def indices(dimensions, dtype: Optional[DTypeLike] = ..., sparse=...): # -> tuple[()] | tuple[Any, ...]:
    ...

def tril(m: ArrayLike, k=...): # -> Tensor:
    ...

def triu(m: ArrayLike, k=...): # -> Tensor:
    ...

def tril_indices(n, k=..., m=...): # -> Tensor:
    ...

def triu_indices(n, k=..., m=...): # -> Tensor:
    ...

def tril_indices_from(arr: ArrayLike, k=...): # -> Tensor:
    ...

def triu_indices_from(arr: ArrayLike, k=...): # -> Tensor:
    ...

def tri(N, M=..., k=..., dtype: Optional[DTypeLike] = ..., *, like: NotImplementedType = ...): # -> Tensor:
    ...

def isclose(a: ArrayLike, b: ArrayLike, rtol=..., atol=..., equal_nan=...): # -> Tensor:
    ...

def allclose(a: ArrayLike, b: ArrayLike, rtol=..., atol=..., equal_nan=...): # -> bool:
    ...

def array_equal(a1: ArrayLike, a2: ArrayLike, equal_nan=...): # -> Literal[False]:
    ...

def array_equiv(a1: ArrayLike, a2: ArrayLike): # -> Any | Literal[False]:
    ...

def nan_to_num(x: ArrayLike, copy: NotImplementedType = ..., nan=..., posinf=..., neginf=...): # -> Tensor:
    ...

def take(a: ArrayLike, indices: ArrayLike, axis=..., out: Optional[OutArray] = ..., mode: NotImplementedType = ...):
    ...

def take_along_axis(arr: ArrayLike, indices: ArrayLike, axis): # -> Tensor:
    ...

def put(a: NDArray, indices: ArrayLike, values: ArrayLike, mode: NotImplementedType = ...): # -> None:
    ...

def put_along_axis(arr: ArrayLike, indices: ArrayLike, values: ArrayLike, axis): # -> None:
    ...

def choose(a: ArrayLike, choices: Sequence[ArrayLike], out: Optional[OutArray] = ..., mode: NotImplementedType = ...):
    ...

def unique(ar: ArrayLike, return_index: NotImplementedType = ..., return_inverse=..., return_counts=..., axis=..., *, equal_nan: NotImplementedType = ...):
    ...

def nonzero(a: ArrayLike):
    ...

def argwhere(a: ArrayLike): # -> Tensor:
    ...

def flatnonzero(a: ArrayLike):
    ...

def clip(a: ArrayLike, min: Optional[ArrayLike] = ..., max: Optional[ArrayLike] = ..., out: Optional[OutArray] = ...):
    ...

def repeat(a: ArrayLike, repeats: ArrayLikeOrScalar, axis=...):
    ...

def tile(A: ArrayLike, reps): # -> Tensor:
    ...

def resize(a: ArrayLike, new_shape=...): # -> ArrayLike | Tensor:
    ...

def diagonal(a: ArrayLike, offset=..., axis1=..., axis2=...): # -> Tensor:
    ...

def trace(a: ArrayLike, offset=..., axis1=..., axis2=..., dtype: Optional[DTypeLike] = ..., out: Optional[OutArray] = ...):
    ...

def eye(N, M=..., k=..., dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...): # -> Tensor:
    ...

def identity(n, dtype: Optional[DTypeLike] = ..., *, like: NotImplementedType = ...): # -> Tensor:
    ...

def diag(v: ArrayLike, k=...): # -> Tensor:
    ...

def diagflat(v: ArrayLike, k=...): # -> Tensor:
    ...

def diag_indices(n, ndim=...): # -> tuple[Tensor, ...]:
    ...

def diag_indices_from(arr: ArrayLike): # -> tuple[Tensor, ...]:
    ...

def fill_diagonal(a: ArrayLike, val: ArrayLike, wrap=...): # -> ArrayLike:
    ...

def vdot(a: ArrayLike, b: ArrayLike, /): # -> Tensor:
    ...

def tensordot(a: ArrayLike, b: ArrayLike, axes=...): # -> Any:
    ...

def dot(a: ArrayLike, b: ArrayLike, out: Optional[OutArray] = ...): # -> Tensor:
    ...

def inner(a: ArrayLike, b: ArrayLike, /): # -> Tensor:
    ...

def outer(a: ArrayLike, b: ArrayLike, out: Optional[OutArray] = ...): # -> Tensor:
    ...

def cross(a: ArrayLike, b: ArrayLike, axisa=..., axisb=..., axisc=..., axis=...): # -> Tensor:
    ...

def einsum(*operands, out=..., dtype=..., order=..., casting=..., optimize=...): # -> ndarray | list[Any] | tuple[Any, ...]:
    ...

def sort(a: ArrayLike, axis=..., kind=..., order: NotImplementedType = ...):
    ...

def argsort(a: ArrayLike, axis=..., kind=..., order: NotImplementedType = ...): # -> Tensor:
    ...

def searchsorted(a: ArrayLike, v: ArrayLike, side=..., sorter: Optional[ArrayLike] = ...):
    ...

def moveaxis(a: ArrayLike, source, destination):
    ...

def swapaxes(a: ArrayLike, axis1, axis2): # -> Tensor:
    ...

def rollaxis(a: ArrayLike, axis, start=...): # -> ArrayLike:
    ...

def roll(a: ArrayLike, shift, axis=...): # -> Tensor:
    ...

def squeeze(a: ArrayLike, axis=...): # -> ArrayLike:
    ...

def reshape(a: ArrayLike, newshape, order: NotImplementedType = ...):
    ...

def transpose(a: ArrayLike, axes=...):
    ...

def ravel(a: ArrayLike, order: NotImplementedType = ...): # -> Tensor:
    ...

def diff(a: ArrayLike, n=..., axis=..., prepend: Optional[ArrayLike] = ..., append: Optional[ArrayLike] = ...): # -> ArrayLike:
    ...

def angle(z: ArrayLike, deg=...): # -> Tensor:
    ...

def sinc(x: ArrayLike): # -> Tensor:
    ...

def gradient(f: ArrayLike, *varargs, axis=..., edge_order=...): # -> list[Any]:
    ...

def round(a: ArrayLike, decimals=..., out: Optional[OutArray] = ...): # -> Tensor | ArrayLike:
    ...

around = ...
round_ = ...
def real_if_close(a: ArrayLike, tol=...): # -> ArrayLike:
    ...

def real(a: ArrayLike): # -> Tensor:
    ...

def imag(a: ArrayLike): # -> Tensor:
    ...

def iscomplex(x: ArrayLike): # -> Tensor:
    ...

def isreal(x: ArrayLike): # -> Tensor:
    ...

def iscomplexobj(x: ArrayLike): # -> bool:
    ...

def isrealobj(x: ArrayLike): # -> bool:
    ...

def isneginf(x: ArrayLike, out: Optional[OutArray] = ...): # -> Tensor:
    ...

def isposinf(x: ArrayLike, out: Optional[OutArray] = ...): # -> Tensor:
    ...

def i0(x: ArrayLike):
    ...

def isscalar(a): # -> Literal[False]:
    ...

def hamming(M): # -> Tensor:
    ...

def hanning(M): # -> Tensor:
    ...

def kaiser(M, beta): # -> Tensor:
    ...

def blackman(M): # -> Tensor:
    ...

def bartlett(M): # -> Tensor:
    ...

array_type = ...
array_precision = ...
def common_type(*tensors: ArrayLike):
    ...

def histogram(a: ArrayLike, bins: ArrayLike = ..., range=..., normed=..., weights: Optional[ArrayLike] = ..., density=...): # -> tuple[Any, Any]:
    ...

def histogram2d(x, y, bins=..., range: Optional[ArrayLike] = ..., normed=..., weights: Optional[ArrayLike] = ..., density=...): # -> tuple[Any, Any, Any]:
    ...

def histogramdd(sample, bins=..., range: Optional[ArrayLike] = ..., normed=..., weights: Optional[ArrayLike] = ..., density=...): # -> tuple[Any, list[Any] | Any]:
    ...

def min_scalar_type(a: ArrayLike, /): # -> DType:
    ...

def pad(array: ArrayLike, pad_width: ArrayLike, mode=..., **kwargs): # -> Tensor:
    ...

