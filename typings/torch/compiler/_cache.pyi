"""
This type stub file was generated by pyright.
"""

import dataclasses
from abc import ABC, abstractmethod
from collections import defaultdict
from collections.abc import Generator
from contextlib import contextmanager
from typing import Any, Optional
from torch.utils._appending_byte_serializer import AppendingByteSerializer, BytesReader, BytesWriter
from torch.utils._ordered_set import OrderedSet

log = ...
@dataclasses.dataclass(frozen=True)
class CacheArtifact(ABC):
    """
    Data for each cache artifact that will be serialized and deserialized
    """
    key: str
    content: bytes = ...
    @staticmethod
    def serialize(writer: BytesWriter, cls: CacheArtifact) -> None:
        ...
    
    @staticmethod
    def deserialize(artifact_type: str, reader: BytesReader) -> CacheArtifact:
        ...
    
    @staticmethod
    def encode(content: Any) -> bytes:
        ...
    
    @abstractmethod
    def populate_cache(self) -> None:
        ...
    
    def precompile_compatible(self) -> bool:
        ...
    
    @staticmethod
    def type() -> str:
        """
        Returns the type of the artifact. Must be unique across all CacheArtifact classes.

        CacheArtifactFactory.register will add property method to CacheInfo based on this (def {type}_artifacts)
        that returns all artifacts for specific cache.
        """
        ...
    


class CacheArtifactFactory:
    """
    Factory for creating CacheArtifact objects based on their type
    """
    _artifact_types: dict[str, type[CacheArtifact]] = ...
    @classmethod
    def register(cls, artifact_cls: type[CacheArtifact]) -> type[CacheArtifact]:
        ...
    
    @classmethod
    def create(cls, artifact_type_key: str, key: str, content: bytes) -> CacheArtifact:
        ...
    
    @classmethod
    def encode_create(cls, artifact_type_key: str, key: str, content: Any) -> CacheArtifact:
        ...
    


@dataclasses.dataclass
class CacheInfo:
    """
    Return value of serialization and deserialization for the purpose of
    instrumentation
    """
    artifacts: defaultdict[str, list[str]] = ...
    @property
    def inductor_artifacts(self) -> list[str]:
        ...
    
    @property
    def autotune_artifacts(self) -> list[str]:
        ...
    
    @property
    def aot_autograd_artifacts(self) -> list[str]:
        ...
    
    @property
    def pgo_artifacts(self) -> list[str]:
        ...
    
    @property
    def precompile_aot_autograd_artifacts(self) -> list[str]:
        ...
    
    def add(self, artifact: CacheArtifact) -> None:
        ...
    
    def clear(self) -> None:
        ...
    
    def empty(self) -> bool:
        ...
    


CacheArtifactsResult = dict[str, list[CacheArtifact]]
class CacheArtifactManager:
    """
    Lightweight manager class for collecting and processing cache artifacts for
    hot loading

    Intended Lifecycle:
    - Execute code via torch.compile, this will call
        CacheArtifactManager.record_artifact on each cache artifact
    - Call CacheArtifactManager.serialize to convert all the cache artifacts
        to portable format
    - Call CacheArtifactManager.deserialize to hot load the cache artifacts on
        a potentially different process

    NOTE: There's no FB/FC guarentees, results of cache artifacts will not be
          used unless code version matches.
    """
    _new_cache_artifacts: CacheArtifactsResult = ...
    _seen_artifacts: OrderedSet[CacheArtifact] = ...
    _serializer: AppendingByteSerializer[tuple[str, list[CacheArtifact]]] = ...
    _cache_info: CacheInfo = ...
    @classmethod
    def clear(cls) -> None:
        ...
    
    @classmethod
    @contextmanager
    def with_fresh_cache(cls) -> Generator[None, None, None]:
        ...
    
    @classmethod
    def record_artifact(cls, artifact_type: str, key: str, content: Any) -> None:
        """
        Called from each caching operation to record the artifact in this
        "mega" list
        """
        ...
    
    @classmethod
    def need_serialize(cls) -> bool:
        """
        Have we seen new artifacts since last serialize call?
        """
        ...
    
    @classmethod
    def serialize(cls) -> Optional[tuple[bytes, CacheInfo]]:
        """
        Converts the "mega" list into portable format
        """
        ...
    
    @staticmethod
    def deserialize(serialized_artifacts: bytes) -> Optional[CacheArtifactsResult]:
        """
        Converts the portable format back into CacheArtifacts
        """
        ...
    
    @staticmethod
    def populate_caches(artifacts: CacheArtifactsResult) -> CacheInfo:
        ...
    


