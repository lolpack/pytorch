"""
This type stub file was generated by pyright.
"""

from collections.abc import Sequence
from torch.distributed.tensor._op_schema import OpSchema, OpStrategy, StrategyType

aten = ...
linear_pointwise_ops = ...
pointwise_ops = ...
def pointwise_strategy(op_schema: OpSchema, linearity: bool = ...) -> OpStrategy:
    ...

def common_pointwise_strategy(args_schema: Sequence[object], followed_strategy: OpStrategy, linearity: bool) -> OpStrategy:
    ...

def linear_pointwise_strategy(op_schema: OpSchema) -> StrategyType:
    """
    Linear pointwise operators can propagate pending reductions.
    For example, c = add(a, b); if a is pending sum, then c will be
    pending sum as well without any communication overhead.
    """
    ...

for_each_ops = ...
for_each_linearity_ops = ...
def list_pointwise_strategy(op_schema: OpSchema, linearity: bool = ...) -> StrategyType:
    """
    Apply the pointwise strategy to the zipped arguments. For example, if we
    run a foreach add of two lists l1 and l2, then we apply the pointwise
    strategy on each pair (l1[i], l2[i]). If the first argument is a list but
    the second (or later) one is a tensor, then we broadcast the tensor by
    replicating it into a list with the length of the first argument.

    Args:
        mesh (DeviceMesh): device mesh for pointwise ops
        op_schema (OpSchema): schema of the operator to generate strategy for
        linearity (bool): specify whether op(a) + op(b) = op(a + b)

    Returns:
        OpStrategy: generated strategy
    """
    ...

def list_linear_pointwise_strategy(op_schema: OpSchema) -> StrategyType:
    """
    for each list op stratgy that supports linearity
    """
    ...

fused_ops = ...
