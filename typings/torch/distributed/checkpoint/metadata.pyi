"""
This type stub file was generated by pyright.
"""

import os
import torch
from collections.abc import Sequence
from dataclasses import dataclass
from enum import Enum
from typing import Any, Optional, Union
from torch.distributed.checkpoint.stateful import StatefulT

__all__ = ["ChunkStorageMetadata", "TensorStorageMetadata", "BytesStorageMetadata", "Metadata", "MetadataIndex", "TensorProperties", "StorageMeta"]
@dataclass
class ChunkStorageMetadata:
    """
    Each chunk is expected to have the same properties of the TensorStorageMetadata
    that includes it.
    """
    offsets: torch.Size
    sizes: torch.Size
    ...


class _MEM_FORMAT_ENCODING(Enum):
    """Describe the memory format of a tensor."""
    TORCH_CONTIGUOUS_FORMAT = ...
    TORCH_CHANNELS_LAST = ...
    TORCH_PRESERVE_FORMAT = ...


@dataclass
class TensorProperties:
    """Properties used to create :class:`Tensor`"""
    dtype: torch.dtype = ...
    layout: torch.layout = ...
    requires_grad: bool = ...
    memory_format: torch.memory_format = ...
    pin_memory: bool = ...
    def __getstate__(self): # -> tuple[dtype, layout, bool, Literal[_MEM_FORMAT_ENCODING.TORCH_CONTIGUOUS_FORMAT, _MEM_FORMAT_ENCODING.TORCH_CHANNELS_LAST, _MEM_FORMAT_ENCODING.TORCH_PRESERVE_FORMAT], bool]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    @staticmethod
    def create_from_tensor(tensor: torch.Tensor) -> TensorProperties:
        ...
    


@dataclass
class TensorStorageMetadata:
    properties: TensorProperties
    size: torch.Size
    chunks: list[ChunkStorageMetadata]
    ...


@dataclass
class BytesStorageMetadata:
    ...


STORAGE_TYPES = Union[TensorStorageMetadata, BytesStorageMetadata]
STATE_DICT_TYPE = dict[str, Union[StatefulT, Any]]
@dataclass
class StorageMeta:
    checkpoint_id: Union[str, os.PathLike, None] = ...
    save_id: Optional[str] = ...
    load_id: Optional[str] = ...
    modules: list[str] = ...


@dataclass
class Metadata:
    """This class represents the metadata of the checkpoint."""
    state_dict_metadata: dict[str, STORAGE_TYPES]
    planner_data: Any = ...
    storage_data: Any = ...
    storage_meta: Optional[StorageMeta] = ...


@dataclass(frozen=True)
class MetadataIndex:
    """This class represents a lookup key for items in a state dict or Metadata."""
    fqn: str
    offset: Optional[torch.Size] = ...
    index: Optional[int] = ...
    def __init__(self, fqn: str, offset: Optional[Sequence[int]] = ..., index: Optional[int] = ...) -> None:
        ...
    


