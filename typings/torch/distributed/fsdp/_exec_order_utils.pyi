"""
This type stub file was generated by pyright.
"""

import torch.distributed as dist
import torch.nn as nn
from enum import Enum
from typing import Optional
from torch.distributed.fsdp._common_utils import _FSDPState
from torch.distributed.fsdp._flat_param import FlatParamHandle

class _ExecOrderWarnStatus(Enum):
    """Used internally for execution order validation."""
    NONE = ...
    WARNING = ...
    WARNED = ...


class _ExecOrderData:
    """
    This contains the data structures to track the execution order. We track
    the pre-forward order on the *first* iteration for forward prefetching
    (which thus assumes static graph) and the post-forward order on *every*
    iteration for backward prefetching (which thus does not assume static
    graph but may be provide an incorrect order).
    """
    def __init__(self, debug_level: dist.DebugLevel, backward_prefetch_limit: int, forward_prefetch_limit: int) -> None:
        ...
    
    def init(self, state: _FSDPState, root_module: nn.Module, process_group: dist.ProcessGroup) -> None:
        """
        Initializes the data structures needed for checking the forward order.
        This should be called after a root FSDP instance has been set during
        lazy initialization.
        """
        ...
    
    @property
    def is_first_iter(self) -> bool:
        ...
    
    def get_handle_to_backward_prefetch(self, current_handle: FlatParamHandle) -> Optional[FlatParamHandle]:
        """
        Returns a :class:`list` of the handles keys of the handles to backward
        prefetch given the current handles key. If there are no valid handles
        keys to prefetch, then this returns an empty :class:`list`.
        """
        ...
    
    def get_handle_to_forward_prefetch(self, current_handle: FlatParamHandle) -> Optional[FlatParamHandle]:
        """
        Returns a :class:`list` of the handles keys of the handles to forward
        prefetch given the current handles key. If there are no valid handles
        keys to prefetch, then this returns an empty :class:`list`.
        """
        ...
    
    def record_post_forward(self, handle: Optional[FlatParamHandle]) -> None:
        """
        Records ``handles`` in the post-forward order, where ``handles`` should
        be a group of handles used in the same module's forward. If ``handles``
        is empty, then it is omitted.

        Unlike :meth:`record_pre_forward`, this records the order *every*
        iteration with the expectation that the recorded order is reset in
        :meth:`next_iter`.
        """
        ...
    
    def record_pre_forward(self, handle: Optional[FlatParamHandle], is_training: bool) -> None:
        """
        Records ``handles`` in the pre-forward order, where ``handles`` should
        be a group of handles used in the same module's forward. If ``handles``
        is empty, then it is omitted.

        On the first iteration, this checks the execution order across ranks.
        See :meth:`_check_order` for details.
        """
        ...
    
    def next_iter(self): # -> None:
        """
        Advances the internal data structures per iteration. This should be
        called in the post-backward callback since that marks the true end of
        an iteration.
        """
        ...
    


