"""
This type stub file was generated by pyright.
"""

_IS_ASTUNPARSE_INSTALLED = ...
_IS_ASTUNPARSE_INSTALLED = ...
_reserved_prefix = ...
_reserved_names = ...
_identifier_chars = ...
def is_reserved_name(name): # -> bool:
    ...

pretty_node_names = ...
node_start_tokens = ...
class FrontendError(Exception):
    def __init__(self, source_range, msg) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class NotSupportedError(FrontendError):
    ...


class UnsupportedNodeError(NotSupportedError):
    def __init__(self, ctx, offending_node, reason=...) -> None:
        ...
    


class FrontendTypeError(FrontendError):
    ...


def build_withitems(ctx, items): # -> list[Any]:
    ...

def build_stmts(ctx, stmts): # -> list[Any]:
    ...

def get_class_properties(cls, self_name): # -> list[Any]:
    """
    Get a list of Property objects representing the properties of a class.

    Args:
        cls:  The class to get properties of.
        self_name: The name of the class that the properties should belong to.
    Returns:
        A list of Property objects corresponding to the properties of cls. Property
        here refers to the subclass of TreeView.
    """
    ...

def get_class_assigns(ctx, cls_ast): # -> list[Any]:
    ...

def get_jit_class_def(cls, self_name): # -> ClassDef:
    """Get definitions for each method within the current class independently.

    Args:
        cls: The class to get definition of.
        self_name: The name of the class that the properties should belong to.

    Returns:
        torch._C._jit_tree_views.ClassDef: A representation of the class,
            the methods in the class and their definition as a tree.
    """
    ...

def get_jit_def(fn, def_name, self_name=..., is_classmethod=...): # -> Def:
    """
    Build a JIT AST (TreeView) from the given function.

    Args:
        fn: A function object to compile or a pre-parsed ParsedDef object
        def_name: The name to give to the resulting AST object. This is not
            always the same as `fn.__name__`, for example:
                def _forward(self):
                    ...
                forward = _forward
            In this case, the `__name__` attribute of the function object is "_forward",
            but we want the result AST to have the name "forward".
        self_name: If this function is a method, what the type name of `self` is.
    """
    ...

def is_torch_jit_ignore_context_manager(stmt): # -> bool:
    ...

class Builder:
    def __call__(self, ctx, node): # -> Any:
        ...
    


def build_class_def(ctx, py_def, methods, properties, self_name, assigns): # -> ClassDef:
    ...

def build_def(ctx, py_def, type_line, def_name, self_name=..., pdt_arg_types=...): # -> Def:
    ...

_vararg_kwarg_err = ...
def build_param_list(ctx, py_args, self_name, pdt_arg_types=...): # -> list[Param]:
    ...

def build_param(ctx, py_arg, self_name, kwarg_only, pdt_arg_type=...): # -> Param:
    ...

def build_ignore_context_manager(ctx, stmt): # -> stmt:
    ...

def get_default_args(fn): # -> dict[Any, Any] | dict[str, Any]:
    """
    Get a dictionary of default arguments for a function.

    Args:
        fn: Callable - The function to inspect for default arguments.
    Returns:
        (Dict[str, Any]): mapping argument names to their default values if
        :attr:`fn` is not None, else empty dictionary.
    """
    ...

def get_default_args_for_class(cls): # -> dict[str, dict[Any, Any] | dict[str, Any]]:
    """
    Get default arguments for all methods in a class (except for static methods).

    Args:
        cls: type - The class type to inspect for default arguments.
    Returns:
        A Dict[str, Dict[str, Any]] which maps each method name to a Dict[str, Any]
        that maps each argument name to its default value.
    """
    ...

class WithItemBuilder(Builder):
    @staticmethod
    def build_withitem(ctx, item): # -> WithItem:
        ...
    


class StmtBuilder(Builder):
    augassign_map = ...
    @staticmethod
    def build_Expr(ctx, stmt): # -> ExprStmt | None:
        ...
    
    @staticmethod
    def build_Assign(ctx, stmt): # -> Assign:
        ...
    
    @staticmethod
    def build_AnnAssign(ctx, stmt): # -> Assign:
        ...
    
    @staticmethod
    def build_Delete(ctx, stmt): # -> Delete:
        ...
    
    @staticmethod
    def build_Return(ctx, stmt): # -> Return:
        ...
    
    @staticmethod
    def build_Raise(ctx, stmt): # -> Raise:
        ...
    
    @staticmethod
    def build_Assert(ctx, stmt): # -> Assert:
        ...
    
    @staticmethod
    def build_AugAssign(ctx, stmt): # -> AugAssign:
        ...
    
    @staticmethod
    def build_While(ctx, stmt): # -> While:
        ...
    
    @staticmethod
    def build_For(ctx, stmt): # -> For:
        ...
    
    @staticmethod
    def build_If(ctx, stmt): # -> If:
        ...
    
    @staticmethod
    def build_Print(ctx, stmt): # -> ExprStmt:
        ...
    
    @staticmethod
    def build_Pass(ctx, stmt): # -> Pass:
        ...
    
    @staticmethod
    def build_Break(ctx, stmt): # -> Break:
        ...
    
    @staticmethod
    def build_Continue(ctx, stmt): # -> Continue:
        ...
    
    @staticmethod
    def build_With(ctx, stmt): # -> Any | With:
        ...
    


class ExprBuilder(Builder):
    binop_map = ...
    unop_map = ...
    boolop_map = ...
    cmpop_map = ...
    @staticmethod
    def build_Attribute(ctx, expr): # -> Select:
        ...
    
    @staticmethod
    def build_Call(ctx, expr): # -> Apply:
        ...
    
    @staticmethod
    def build_Ellipsis(ctx, expr): # -> Dots:
        ...
    
    @staticmethod
    def build_Name(ctx, expr): # -> Any | Dots | Var:
        ...
    
    @staticmethod
    def build_NameConstant(ctx, expr): # -> Any | Dots:
        ...
    
    @staticmethod
    def build_BinOp(ctx, expr): # -> BinOp:
        ...
    
    @staticmethod
    def build_UnaryOp(ctx, expr): # -> UnaryOp:
        ...
    
    @staticmethod
    def build_BoolOp(ctx, expr): # -> Any | BinOp:
        ...
    
    @staticmethod
    def build_IfExp(ctx, expr): # -> TernaryIf:
        ...
    
    @staticmethod
    def build_Compare(ctx, expr): # -> UnaryOp | BinOp | None:
        ...
    
    @staticmethod
    def build_Subscript(ctx, expr): # -> Subscript:
        ...
    
    @staticmethod
    def build_List(ctx, expr): # -> ListLiteral:
        ...
    
    @staticmethod
    def build_Tuple(ctx, expr): # -> TupleLiteral:
        ...
    
    @staticmethod
    def build_Dict(ctx, expr): # -> DictLiteral:
        ...
    
    @staticmethod
    def build_Num(ctx, expr): # -> Const:
        ...
    
    @staticmethod
    def build_Constant(ctx, expr): # -> Any | Dots | Const | StringLiteral:
        ...
    
    @staticmethod
    def build_Str(ctx, expr): # -> StringLiteral:
        ...
    
    @staticmethod
    def build_JoinedStr(ctx, expr): # -> Apply:
        ...
    
    @staticmethod
    def build_ListComp(ctx, stmt): # -> ListComp:
        ...
    
    @staticmethod
    def build_GeneratorExp(ctx, stmt): # -> ListComp:
        ...
    
    @staticmethod
    def build_DictComp(ctx, stmt): # -> DictComp:
        ...
    
    @staticmethod
    def build_Starred(ctx, expr): # -> Starred:
        ...
    


build_expr = ...
build_stmt = ...
build_withitem = ...
def find_before(ctx, pos, substr, offsets=...):
    ...

