"""
This type stub file was generated by pyright.
"""

import numpy
import torch
from collections.abc import Iterable, Iterator, Sequence
from enum import Enum, IntEnum
from pathlib import Path
from types import EllipsisType
from typing import Any, AnyStr, Callable, Generic, IO, Literal, NamedTuple, SupportsIndex, TypeVar, overload
from typing_extensions import ParamSpec, Protocol, Self, TypeAlias, runtime_checkable
from torch import SymInt, Tensor, inf
from torch._C import _VariableFunctions, _aoti, _cpu, _dynamo, _export, _functorch, _lazy, _lazy_ts_backend, _nn, _onnx, _verbose
from torch._prims_common import DeviceLikeType
from torch.autograd.graph import Node as _Node
from torch.fx.node import Node as FxNode
from torch.package import PackageExporter
from torch.storage import TypedStorage, UntypedStorage
from torch.types import Device, IntLikeType, Number, Storage, _bool, _bytes, _complex, _device, _dispatchkey, _dtype, _float, _int, _layout, _qscheme, _size, _str, _symsize
from torch.utils._python_dispatch import TorchDispatchMode

K = TypeVar("K")
T = TypeVar("T")
S = TypeVar("S", bound=torch.Tensor)
P = ParamSpec("P")
R = TypeVar("R", covariant=True)
T_co = TypeVar("T_co", covariant=True)
@runtime_checkable
class _NestedSequence(Protocol[T_co]):
    """A protocol for representing nested sequences.

    References::
        `numpy._typing._NestedSequence`
        <https://github.com/numpy/numpy/blob/main/numpy/_typing/_nested_sequence.py>
    """
    def __len__(self, /) -> _int:
        ...
    
    def __getitem__(self, index: _int, /) -> T_co | _NestedSequence[T_co]:
        ...
    
    def __contains__(self, x: object, /) -> _bool:
        ...
    
    def __iter__(self, /) -> Iterator[T_co | _NestedSequence[T_co]]:
        ...
    
    def __reversed__(self, /) -> Iterator[T_co | _NestedSequence[T_co]]:
        ...
    
    def count(self, value: Any, /) -> _int:
        ...
    
    def index(self, value: Any, /) -> _int:
        ...
    


class device:
    type: str
    index: _int
    def __get__(self, instance, owner=...) -> device:
        ...
    
    @overload
    def __init__(self, device: DeviceLikeType) -> None:
        ...
    
    @overload
    def __init__(self, type: str, index: _int) -> None:
        ...
    
    def __enter__(self) -> Self:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        ...
    
    def __reduce__(self) -> tuple[Any, ...]:
        ...
    


class Stream:
    stream_id: _int
    device_index: _int
    device_type: _int
    device: _device
    @overload
    def __new__(cls, device: DeviceLikeType | None = ..., *, priority: _int = ...) -> Self:
        ...
    
    @overload
    def __new__(cls, stream_id: _int, device_index: _int, device_type: _int, *, priority: _int = ...) -> Self:
        ...
    
    def query(self) -> _bool:
        ...
    
    def synchronize(self) -> None:
        ...
    
    def wait_event(self, event: Event) -> None:
        ...
    
    def wait_stream(self, other: Stream) -> None:
        ...
    
    def record_event(self, event: Event | None = ...) -> Event:
        ...
    
    def __hash__(self) -> _int:
        ...
    
    def __eq__(self, other: object) -> _bool:
        ...
    
    def __enter__(self) -> Self:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        ...
    


class Event:
    device: _device
    event_id: _int
    def __new__(cls, device: DeviceLikeType | None = ..., *, enable_timing: _bool = ..., blocking: _bool = ..., interprocess: _bool = ...) -> Self:
        ...
    
    @classmethod
    def from_ipc_handle(cls, device: _device, ipc_handle: bytes) -> Event:
        ...
    
    def record(self, stream: Stream | None = ...) -> None:
        ...
    
    def wait(self, stream: Stream | None = ...) -> None:
        ...
    
    def query(self) -> _bool:
        ...
    
    def elapsed_time(self, other: Event) -> _float:
        ...
    
    def synchronize(self) -> None:
        ...
    
    def ipc_handle(self) -> bytes:
        ...
    


class Size(tuple[_int, ...]):
    @overload
    def __getitem__(self: Size, key: SupportsIndex, /) -> _int:
        ...
    
    @overload
    def __getitem__(self: Size, key: slice, /) -> Size:
        ...
    
    def __add__(self, other: tuple[_int, ...], /) -> Size:
        ...
    
    def __mul__(self, other: SupportsIndex, /) -> Size:
        ...
    
    def __rmul__(self, other: SupportsIndex, /) -> Size:
        ...
    
    def numel(self: Size, /) -> _int:
        ...
    


class dtype:
    is_floating_point: _bool
    is_complex: _bool
    is_signed: _bool
    itemsize: _int
    def to_real(self) -> dtype:
        ...
    
    def to_complex(self) -> dtype:
        ...
    


class iinfo:
    bits: _int
    min: _int
    max: _int
    dtype: str
    def __init__(self, dtype: _dtype) -> None:
        ...
    


class finfo:
    bits: _int
    min: _float
    max: _float
    eps: _float
    tiny: _float
    smallest_normal: _float
    resolution: _float
    dtype: str
    @overload
    def __init__(self, dtype: _dtype) -> None:
        ...
    
    @overload
    def __init__(self) -> None:
        ...
    


class layout:
    ...


def DisableTorchFunction():
    ...

def DisableTorchFunctionSubclass():
    ...

strided: layout = ...
sparse_coo: layout = ...
sparse_csr: layout = ...
sparse_csc: layout = ...
sparse_bsr: layout = ...
sparse_bsc: layout = ...
_mkldnn: layout = ...
jagged: layout = ...
class memory_format:
    ...


contiguous_format: memory_format = ...
channels_last: memory_format = ...
channels_last_3d: memory_format = ...
preserve_format: memory_format = ...
class qscheme:
    ...


per_tensor_affine: qscheme = ...
per_channel_affine: qscheme = ...
per_tensor_symmetric: qscheme = ...
per_channel_symmetric: qscheme = ...
per_channel_affine_float_qparams: qscheme = ...
class _FunctionBase:
    saved_tensors: tuple[Tensor]
    _raw_saved_tensors: tuple[Any]
    next_functions: tuple[tuple[Any, _int], ...]
    needs_input_grad: tuple[_bool]
    metadata: dict
    _materialize_non_diff_grads: _bool
    ...


class _LegacyVariableBase(Tensor):
    def __init__(self, data: Tensor | None = ..., requires_grad: _bool | None = ..., volatile: _bool | None = ..., _grad_fn: _FunctionBase | None = ...) -> None:
        ...
    


class IODescriptor:
    ...


class JITException(Exception):
    ...


class Future(Generic[T]):
    def __init__(self, devices: list[device]) -> None:
        ...
    
    def done(self) -> _bool:
        ...
    
    def value(self) -> T:
        ...
    
    def wait(self) -> T:
        ...
    
    def add_done_callback(self, callback: Callable) -> None:
        ...
    
    def then(self, callback: Callable) -> Future[T]:
        ...
    
    def set_result(self, result: T) -> None:
        ...
    


class _Await:
    def __init__(self) -> None:
        ...
    
    def fn(self) -> Callable:
        ...
    
    def args(self) -> tuple[Any, ...]:
        ...
    
    def is_nowait(self) -> _bool:
        ...
    


class _MobileOptimizerType:
    ...


CONV_BN_FUSION: _MobileOptimizerType
INSERT_FOLD_PREPACK_OPS: _MobileOptimizerType
REMOVE_DROPOUT: _MobileOptimizerType
FUSE_ADD_RELU: _MobileOptimizerType
HOIST_CONV_PACKED_PARAMS: _MobileOptimizerType
VULKAN_AUTOMATIC_GPU_TRANSFER: _MobileOptimizerType
def fork(*args: Any, **kwargs: Any) -> Future:
    ...

def wait(fut: Future) -> Any:
    ...

def unify_type_list(types: list[JitType]) -> JitType:
    ...

ResolutionCallback: TypeAlias = Callable[[str], Callable[..., Any]]
def parse_type_comment(comment: str) -> Decl:
    ...

def merge_type_from_type_comment(decl: Decl, type_annotation_decl: Decl, is_method: _bool) -> Decl:
    ...

def parse_ir(input: str, parse_tensor_constants: _bool = ...) -> Graph:
    ...

def parse_schema(schema: str) -> FunctionSchema:
    ...

def get_device(input: Tensor) -> _int:
    ...

def import_ir_module(cu: CompilationUnit, filename: str | Path, map_location: DeviceLikeType | None, extra_files: dict[str, Any]) -> ScriptModule:
    ...

def import_ir_module_from_buffer(cu: CompilationUnit, buffer: IO[bytes], map_location: DeviceLikeType | None, extra_files: dict[str, Any]) -> ScriptModule:
    ...

class GraphExecutorState:
    ...


class AliasDb:
    ...


class _InsertPoint:
    def __enter__(self) -> None:
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class Use:
    @property
    def user(self) -> Node:
        ...
    
    @property
    def offset(self) -> _int:
        ...
    
    def isAfter(self, other: Use) -> _bool:
        ...
    


class Value:
    def type(self) -> JitType:
        ...
    
    def setType(self, t: JitType) -> Value:
        ...
    
    def setTypeAs(self, other: Value) -> Value:
        ...
    
    def inferTypeFrom(self, t: Tensor) -> None:
        ...
    
    def debugName(self) -> str:
        ...
    
    def setDebugName(self, name: str) -> None:
        ...
    
    def unique(self) -> _int:
        ...
    
    def offset(self) -> _int:
        ...
    
    def node(self) -> Node:
        ...
    
    def uses(self) -> list[Use]:
        ...
    
    def replaceAllUsesWith(self, val: Value) -> None:
        ...
    
    def replaceAllUsesAfterNodeWith(self, node: Node, val: Value) -> None:
        ...
    
    def requires_grad(self) -> _bool:
        ...
    
    def requiresGrad(self) -> _bool:
        ...
    
    def copyMetadata(self, other: Value) -> Value:
        ...
    
    def isCompleteTensor(self) -> _bool:
        ...
    
    def toIValue(self) -> IValue:
        ...
    


class Block:
    def inputs(self) -> Iterator[Value]:
        ...
    
    def outputs(self) -> Iterator[Value]:
        ...
    
    def nodes(self) -> Iterator[Node]:
        ...
    
    def paramNode(self) -> Node:
        ...
    
    def returnNode(self) -> Node:
        ...
    
    def owningNode(self) -> Node:
        ...
    
    def registerOutput(self, n: Value) -> _int:
        ...
    
    def addNode(self, name: str, inputs: Sequence[Value]) -> Node:
        ...
    


class Node:
    def __getitem__(self, key: str) -> Any:
        ...
    
    def schema(self) -> str:
        ...
    
    def input(self) -> Value:
        ...
    
    def inputs(self) -> Iterator[Value]:
        ...
    
    def inputsAt(self, idx: _int) -> Value:
        ...
    
    def inputsSize(self) -> _int:
        ...
    
    def output(self) -> Value:
        ...
    
    def outputs(self) -> Iterator[Value]:
        ...
    
    def outputsAt(self, idx: _int) -> Value:
        ...
    
    def outputsSize(self) -> _int:
        ...
    
    def hasMultipleOutputs(self) -> _bool:
        ...
    
    def blocks(self) -> list[Block]:
        ...
    
    def addBlock(self) -> Block:
        ...
    
    def mustBeNone(self) -> _bool:
        ...
    
    def matches(self, pattern: str) -> _bool:
        ...
    
    def kind(self) -> str:
        ...
    
    def kindOf(self, name: str) -> str:
        ...
    
    def addInput(self, name: str) -> Value:
        ...
    
    def replaceInput(self, i: _int, newValue: Value) -> Value:
        ...
    
    def replaceInputWith(self, from_: Value, to: Value) -> None:
        ...
    
    def replaceAllUsesWith(self, n: Node) -> None:
        ...
    
    def insertBefore(self, n: Node) -> Node:
        ...
    
    def insertAfter(self, n: Node) -> Node:
        ...
    
    def isBefore(self, n: Node) -> _bool:
        ...
    
    def isAfter(self, n: Node) -> _bool:
        ...
    
    def moveBefore(self, n: Node) -> None:
        ...
    
    def moveAfter(self, n: Node) -> None:
        ...
    
    def removeInput(self, i: _int) -> None:
        ...
    
    def removeAllInputs(self, i: _int) -> None:
        ...
    
    def hasUses(self) -> _bool:
        ...
    
    def eraseOutput(self, i: _int) -> None:
        ...
    
    def addOutput(self) -> Value:
        ...
    
    def scopeName(self) -> str:
        ...
    
    def isNondeterministic(self) -> _bool:
        ...
    
    def copyAttributes(self, rhs: Node) -> Node:
        ...
    
    def copyMetadata(self, rhs: Node) -> Node:
        ...
    
    def hasAttributes(self) -> _bool:
        ...
    
    def hasAttribute(self, name: str) -> _bool:
        ...
    
    def removeAttribute(self, attr: str) -> Node:
        ...
    
    def namedInput(self, name: str) -> Value:
        ...
    
    def sourceRange(self) -> SourceRange:
        ...
    
    def owningBlock(self) -> Block:
        ...
    
    def findNode(self, kind: str, recurse: _bool = ...) -> Node:
        ...
    
    def findAllNodes(self, kind: str, recurse: _bool = ...) -> list[Node]:
        ...
    
    def getModuleHierarchy(self) -> str:
        ...
    
    def prev(self) -> Node:
        ...
    
    def destroy(self) -> None:
        ...
    
    def attributeNames(self) -> list[str]:
        ...
    
    def f(self, name: str) -> _float:
        ...
    
    def f_(self, name: str, val: _float) -> Node:
        ...
    
    def fs(self, name: str) -> list[_float]:
        ...
    
    def fs_(self, name: str, val: list[_float]) -> Node:
        ...
    
    def c(self, name: str) -> complex:
        ...
    
    def c_(self, name: str, val: complex) -> Node:
        ...
    
    def s(self, name: str) -> str:
        ...
    
    def s_(self, name: str, val: str) -> Node:
        ...
    
    def ss(self, name: str) -> list[str]:
        ...
    
    def ss_(self, name: str, val: list[str]) -> Node:
        ...
    
    def i(self, name: str) -> _int:
        ...
    
    def i_(self, name: str, val: _int) -> Node:
        ...
    
    def g(self, name: str) -> Graph:
        ...
    
    def g_(self, name: str, val: Graph) -> Node:
        ...
    
    def gs(self, name: str) -> list[Graph]:
        ...
    
    def gs_(self, name: str, val: list[Graph]) -> Node:
        ...
    
    def ival(self, name: str) -> IValue:
        ...
    
    def ival_(self, name: str, val: IValue) -> Node:
        ...
    
    def t(self, name: str) -> Tensor:
        ...
    
    def t_(self, name: str, val: Tensor) -> Node:
        ...
    
    def ts(self, name: str) -> list[Tensor]:
        ...
    
    def ts_(self, name: str, val: list[Tensor]) -> Node:
        ...
    
    def ty(self, name: str) -> JitType:
        ...
    
    def ty_(self, name: str, val: JitType) -> Node:
        ...
    
    def tys(self, name: str) -> list[JitType]:
        ...
    
    def tys_(self, name: str, val: list[JitType]) -> Node:
        ...
    


class Graph:
    def inputs(self) -> Iterator[Value]:
        ...
    
    def outputs(self) -> Iterator[Value]:
        ...
    
    def nodes(self) -> Iterator[Node]:
        ...
    
    def param_node(self) -> Node:
        ...
    
    def return_node(self) -> Node:
        ...
    
    def addInput(self, name: str = ...) -> Value:
        ...
    
    def eraseInput(self, i: _int) -> None:
        ...
    
    def registerOutput(self, n: Value) -> _int:
        ...
    
    def eraseOutput(self, i: _int) -> None:
        ...
    
    def create(self, name: str, args, num_outputs: _int) -> Node:
        ...
    
    def appendNode(self, n: Node) -> Node:
        ...
    
    def prependNode(self, n: Node) -> Node:
        ...
    
    def insertNode(self, n: Node) -> Node:
        ...
    
    def block(self) -> Block:
        ...
    
    def lint(self) -> None:
        ...
    
    def alias_db(self) -> AliasDb:
        ...
    
    def setInsertPoint(self, n: Block | Node) -> None:
        ...
    
    def insert_point_guard(self, n: Block | Node) -> _InsertPoint:
        ...
    
    def insertPoint(self) -> Node:
        ...
    
    def insertGraph(self, callee: Graph, inputs: list[Value]) -> list[Value]:
        ...
    
    def makeMultiOutputIntoTuple(self) -> None:
        ...
    
    def copy(self) -> Graph:
        ...
    


class AliasInfo:
    is_write: _bool
    before_set: set[str]
    after_set: set[str]
    def __init__(self, is_write: _bool, before_set: set[str], after_set: set[str]) -> None:
        ...
    


class Argument:
    name: str
    type: JitType
    default_value: Any | None
    def has_default_value(self) -> _bool:
        ...
    
    kwarg_only: _bool
    is_out: _bool
    alias_info: AliasInfo | None
    is_write: _bool
    real_type: JitType
    def __init__(self, name: str, type: JitType, N: _int | None, defualt_value: Any | None, kwarg_only: _bool, alias_info: AliasInfo | None) -> None:
        ...
    


class FunctionSchema:
    arguments: list[Argument]
    returns: list[Argument]
    name: str
    overload_name: str
    is_mutable: _bool
    def __init__(self, name: str, overload_name: str, arguments: list[Argument], returns: list[Argument], is_vararg: _bool, is_varret: _bool) -> None:
        ...
    


class _UpgraderEntry:
    bumped_at_version: _int
    upgrader_name: str
    old_schema: str
    def __init__(self, bumped_at_version: _int, upgrader_name: str, old_schema: str) -> None:
        ...
    


class _UpgraderRange:
    min_version: _int
    max_version: _int
    ...


class ScriptModuleSerializer:
    def __init__(self, export_writer: PyTorchFileWriter) -> None:
        ...
    
    def serialize(self, model: ScriptModule, script_module_id: _int) -> None:
        ...
    
    def write_files(self) -> None:
        ...
    
    def storage_context(self) -> SerializationStorageContext:
        ...
    


class SerializationStorageContext:
    def __init__(self) -> None:
        ...
    
    def has_storage(self, storage: Storage) -> _bool:
        ...
    
    def get_or_add_storage(self, storage: Storage) -> _int:
        ...
    


class DeserializationStorageContext:
    def __init__(self) -> None:
        ...
    
    def get_storage(self, name: str, dtype: _dtype) -> Tensor:
        ...
    
    def has_storage(self, name: str) -> _bool:
        ...
    
    def add_storage(self, name: str, tensor: Tensor) -> _int:
        ...
    


class ConcreteModuleTypeBuilder:
    def __init__(self, obj: Any) -> None:
        ...
    
    def set_module_dict(self):
        ...
    
    def set_module_list(self):
        ...
    
    def set_parameter_list(self):
        ...
    
    def set_parameter_dict(self):
        ...
    
    def add_attribute(self, name: str, ty: JitType, is_param: _bool, is_buffer: _bool):
        ...
    
    def add_module(self, name: str, meta: ConcreteModuleType):
        ...
    
    def add_constant(self, name: str, value: Any):
        ...
    
    def add_overload(self, method_name: str, overloaded_method_names: list[str]):
        ...
    
    def add_builtin_function(self, name: str, symbol_name: str):
        ...
    
    def add_failed_attribute(self, name: str, failure_reason: str):
        ...
    
    def add_function_attribute(self, name: str, ty: JitType, func: Callable[..., Any]):
        ...
    
    def add_ignored_attribute(self, name: str):
        ...
    
    def add_ignored_attributes(self, names: list[str]):
        ...
    
    def add_forward_hook(self, hook: Callable[..., Any]):
        ...
    
    def add_forward_pre_hook(self, pre_hook: Callable[..., Any]):
        ...
    


class ConcreteModuleType:
    def get_constants(self) -> dict[str, Any]:
        ...
    
    def equals(self, other: ConcreteModuleType) -> _bool:
        ...
    
    @staticmethod
    def from_jit_type(ty: JitType) -> ConcreteModuleType:
        ...
    


class CallStack:
    def __init__(self, name: str, range: SourceRange) -> None:
        ...
    


class ErrorReport:
    def __init__(self, range: SourceRange) -> None:
        ...
    
    def what(self) -> str:
        ...
    
    @staticmethod
    def call_stack() -> str:
        ...
    


class CompilationUnit:
    def __init__(self, lang: str = ..., _frames_up: _int = ...) -> None:
        ...
    
    def find_function(self, name: str) -> ScriptFunction:
        ...
    
    def __getattr__(self, name: str) -> ScriptFunction:
        ...
    
    def define(self, script: str, rcb: ResolutionCallback = ..., _frames_up: _int = ...):
        ...
    
    def get_interface(self, name: str) -> InterfaceType:
        ...
    
    def get_functions(self) -> list[ScriptFunction]:
        ...
    
    def create_function(self, name: str, graph: Graph, shouldMangle: _bool = ...) -> ScriptFunction:
        ...
    
    def get_class(self, name: str) -> ClassType:
        ...
    


class ScriptObject:
    def setattr(self, name: str, value: Any):
        ...
    


class ScriptModule(ScriptObject):
    ...


class LiteScriptModule:
    def __call__(self, *input):
        ...
    
    def find_method(self, method_name: str):
        ...
    
    def forward(self, *input) -> list[str]:
        ...
    
    def run_method(self, method_name: str, *input):
        ...
    


class ScriptFunction(Generic[P, R]):
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:
        ...
    
    def save(self, filename: str, _extra_files: dict[str, bytes]) -> None:
        ...
    
    def save_to_buffer(self, _extra_files: dict[str, bytes]) -> bytes:
        ...
    
    @property
    def graph(self) -> Graph:
        ...
    
    def inlined_graph(self) -> Graph:
        ...
    
    def schema(self) -> FunctionSchema:
        ...
    
    def code(self) -> str:
        ...
    
    def name(self) -> str:
        ...
    
    @property
    def qualified_name(self) -> str:
        ...
    


class ScriptMethod(Generic[P, R]):
    graph: Graph
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:
        ...
    
    @property
    def owner(self) -> ScriptModule:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def schema(self) -> FunctionSchema:
        ...
    


class ScriptDict(Generic[K, T]):
    def __init__(self, dict: dict[K, T]) -> None:
        ...
    
    def __len__(self) -> _int:
        ...
    
    def __contains__(self, key: K) -> _bool:
        ...
    
    def __getitem__(self, key: K) -> T:
        ...
    
    def __setitem__(self, key: K, value: T) -> None:
        ...
    
    def __delitem__(self, key: K) -> None:
        ...
    
    def __iter__(self) -> Iterator[K]:
        ...
    
    def items(self) -> Iterator[tuple[K, T]]:
        ...
    
    def keys(self) -> Iterator[K]:
        ...
    


class ScriptList(Generic[T]):
    def __init__(self, list: list[T]) -> None:
        ...
    
    def __len__(self) -> _int:
        ...
    
    def __contains__(self, item: T) -> _bool:
        ...
    
    @overload
    def __getitem__(self, idx: _int) -> T:
        ...
    
    @overload
    def __getitem__(self, idx: slice) -> ScriptList[T]:
        ...
    
    @overload
    def __setitem__(self, idx: _int, value: T) -> None:
        ...
    
    @overload
    def __setitem__(self, idx: slice, value: list[T]) -> None:
        ...
    
    def __delitem__(self, idx: _int) -> None:
        ...
    
    def __iter__(self) -> Iterator[T]:
        ...
    
    def count(self, value: T) -> _int:
        ...
    
    def remove(self, value: T) -> None:
        ...
    
    def append(self, value: T) -> None:
        ...
    
    def clear(self) -> None:
        ...
    
    @overload
    def extend(self, values: list[T]) -> None:
        ...
    
    @overload
    def extend(self, values: Iterable[T]) -> None:
        ...
    
    @overload
    def pop(self) -> T:
        ...
    
    @overload
    def pop(self, idx: _int) -> T:
        ...
    


class ModuleDict:
    def __init__(self, mod: ScriptModule) -> None:
        ...
    
    def items(self) -> list[tuple[str, Any]]:
        ...
    


class ParameterDict:
    def __init__(self, mod: ScriptModule) -> None:
        ...
    


class BufferDict:
    def __init__(self, mod: ScriptModule) -> None:
        ...
    


class Module:
    ...


def get_num_thread() -> _int:
    ...

def set_num_threads(nthreads: _int) -> None:
    ...

def get_num_interop_threads() -> _int:
    ...

def set_num_interop_threads(nthreads: _int) -> None:
    ...

def set_flush_denormal(arg: _bool) -> _bool:
    ...

def get_default_dtype() -> _dtype:
    ...

class _LinalgBackend:
    Default: _LinalgBackend
    Cusolver: _LinalgBackend
    Magma: _LinalgBackend
    ...


class BatchNormBackend(Enum):
    ...


class _BlasBackend:
    Default: _BlasBackend
    Cublas: _BlasBackend
    Cublaslt: _BlasBackend
    Ck: _BlasBackend
    ...


class _ROCmFABackend:
    Default: _ROCmFABackend
    AOTriton: _ROCmFABackend
    Ck: _ROCmFABackend
    ...


class ConvBackend(Enum):
    ...


class Tag(Enum):
    ...


has_openmp: _bool
has_mkl: _bool
_has_kleidiai: _bool
_has_mps: _bool
has_lapack: _bool
_has_cuda: _bool
_has_magma: _bool
_has_xpu: _bool
_has_mkldnn: _bool
_has_cudnn: _bool
_has_cusparselt: _bool
has_spectral: _bool
_GLIBCXX_USE_CXX11_ABI: _bool
default_generator: Generator
def is_grad_enabled() -> _bool:
    ...

def is_inference_mode_enabled() -> _bool:
    ...

@overload
def set_autocast_enabled(device_type: str, enabled: _bool) -> None:
    ...

@overload
def set_autocast_enabled(enabled: _bool) -> None:
    ...

@overload
def is_autocast_enabled(device_type: str) -> _bool:
    ...

@overload
def is_autocast_enabled() -> _bool:
    ...

def set_autocast_dtype(device_type: str, dtype: _dtype) -> None:
    ...

def get_autocast_dtype(device_type: str) -> _dtype:
    ...

def clear_autocast_cache() -> None:
    ...

def set_autocast_cpu_enabled(enabled: _bool) -> None:
    ...

def is_autocast_cpu_enabled() -> _bool:
    ...

def set_autocast_cpu_dtype(dtype: _dtype) -> None:
    ...

def set_autocast_gpu_dtype(dtype: _dtype) -> None:
    ...

def get_autocast_cpu_dtype() -> _dtype:
    ...

def get_autocast_gpu_dtype() -> _dtype:
    ...

def autocast_increment_nesting() -> _int:
    ...

def autocast_decrement_nesting() -> _int:
    ...

def is_autocast_cache_enabled() -> _bool:
    ...

def set_autocast_cache_enabled(enabled: _bool) -> None:
    ...

def set_anomaly_enabled(enabled: _bool, check_nan: _bool = ...) -> None:
    ...

def is_anomaly_enabled() -> _bool:
    ...

def is_anomaly_check_nan_enabled() -> _bool:
    ...

class _DisableTorchDispatch:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _EnableTorchFunction:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _EnablePythonDispatcher:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _DisablePythonDispatcher:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _EnablePreDispatch:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _DisableFuncTorch:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _DisableAutocast:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _InferenceMode:
    def __init__(self, enabled: _bool) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class LoggerBase:
    ...


class NoopLogger(LoggerBase):
    ...


class LockingLogger(LoggerBase):
    ...


class AggregationType(Enum):
    SUM = ...
    AVG = ...


class FileCheck:
    def run(self, test_string: str) -> None:
        ...
    
    def check(self, test_string: str) -> FileCheck:
        ...
    
    def check_not(self, test_string: str) -> FileCheck:
        ...
    
    def check_same(self, test_string: str) -> FileCheck:
        ...
    
    def check_next(self, test_string: str) -> FileCheck:
        ...
    
    def check_count(self, test_string: str, count: _int, exactly: _bool = ...) -> FileCheck:
        ...
    
    def check_dag(self, test_string: str) -> FileCheck:
        ...
    
    def check_source_highlighted(self, test_string: str) -> FileCheck:
        ...
    
    def check_regex(self, test_string: str) -> FileCheck:
        ...
    


class PyTorchFileReader:
    @overload
    def __init__(self, name: str) -> None:
        ...
    
    @overload
    def __init__(self, buffer: IO[bytes]) -> None:
        ...
    
    def get_record(self, name: str) -> bytes:
        ...
    
    def get_all_records(self) -> list[str]:
        ...
    
    def serialization_id(self) -> str:
        ...
    


class PyTorchFileWriter:
    @overload
    def __init__(self, name: str, compute_crc32: _bool = ..., storage_alignment: _int = ...) -> None:
        ...
    
    @overload
    def __init__(self, buffer: IO[bytes], compute_crc32: _bool = ..., storage_alignment: _int = ...) -> None:
        ...
    
    def write_record(self, name: str, data: Storage | bytes | _int, size: _int) -> None:
        ...
    
    def write_end_of_file(self) -> None:
        ...
    
    def set_min_version(self, version: _int) -> None:
        ...
    
    def get_all_written_records(self) -> list[str]:
        ...
    
    def archive_name(self) -> str:
        ...
    
    def serialization_id(self) -> str:
        ...
    


class Generator:
    device: _device
    def __init__(self, device: DeviceLikeType | None = ...) -> None:
        ...
    
    def __reduce__(self) -> tuple[type[Generator], tuple[_device], tuple[_int, _int | None, Tensor]]:
        ...
    
    def __setstate__(self, state: tuple[_int, _int | None, Tensor]) -> None:
        ...
    
    def get_state(self) -> Tensor:
        ...
    
    def set_state(self, _new_state: Tensor) -> Generator:
        ...
    
    def clone_state(self) -> Generator:
        ...
    
    def graphsafe_get_state(self) -> Generator:
        ...
    
    def graphsafe_set_state(self, _new_state: Generator) -> Generator:
        ...
    
    def set_offset(self, offset: _int) -> Generator:
        ...
    
    def get_offset(self) -> _int:
        ...
    
    def manual_seed(self, seed: _int) -> Generator:
        ...
    
    def seed(self) -> _int:
        ...
    
    def initial_seed(self) -> _int:
        ...
    


class _DispatchOperatorHandle:
    def schema(self) -> FunctionSchema:
        ...
    
    def debug(self) -> str:
        ...
    


class _DispatchModule:
    def reset(self) -> None:
        ...
    
    def def_(self, schema: str, alias: str = ...) -> _DispatchModule:
        ...
    
    def def_legacy(self, schema: str) -> _DispatchModule:
        ...
    
    def def_name_t_t(self, name: str, dispatch: str, debug: str = ...) -> _DispatchModule:
        ...
    
    def def_schema_t_t(self, schema: str, dispatch: str, alias: str, debug: str = ...) -> _DispatchModule:
        ...
    
    def impl_t_t(self, name: str, dispatch: str, debug: str = ...) -> _DispatchModule:
        ...
    
    def impl_with_aoti_compile(self, ns: str, op_name_with_overload: str, dispatch: _dispatchkey) -> None:
        ...
    
    def impl(self, name: str, dispatch: _dispatchkey, func: Callable) -> None:
        ...
    
    def define(self, schema: str, alias: str = ...) -> str:
        ...
    
    def fallback_fallthrough(self, dispatch: str = ...) -> _DispatchModule:
        ...
    
    def fallback(self, dispatch: _dispatchkey, func: Callable, with_keyset: _bool = ...) -> None:
        ...
    


_after_ADInplaceOrView_keyset: DispatchKeySet
_after_autograd_keyset: DispatchKeySet
class DispatchKey(Enum):
    ...


class DispatchKeySet:
    def __init__(self, key: DispatchKey) -> None:
        ...
    
    def __or__(self, other: DispatchKeySet) -> DispatchKeySet:
        ...
    
    def __sub__(self, other: DispatchKeySet) -> DispatchKeySet:
        ...
    
    def __and__(self, other: DispatchKeySet) -> DispatchKeySet:
        ...
    
    def raw_repr(self) -> _int:
        ...
    
    @staticmethod
    def from_raw_repr(raw: _int) -> DispatchKeySet:
        ...
    
    def highestPriorityTypeId(self) -> DispatchKey:
        ...
    
    def has(self, k: _dispatchkey) -> _bool:
        ...
    
    def add(self, k: _dispatchkey) -> DispatchKeySet:
        ...
    
    def remove(self, k: _dispatchkey) -> DispatchKeySet:
        ...
    


_dispatch_autogradother_backends: DispatchKeySet
_additional_keys_to_prop_for_wrapper_tensors: DispatchKeySet
class _ExcludeDispatchKeyGuard:
    def __init__(self, keyset: DispatchKeySet) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _IncludeDispatchKeyGuard:
    def __init__(self, k: DispatchKey) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _ForceDispatchKeyGuard:
    def __init__(self, include: DispatchKeySet, exclude: DispatchKeySet) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _PreserveDispatchKeyGuard:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _AutoDispatchBelowAutograd:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _AutoDispatchBelowADInplaceOrView:
    def __init__(self) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _TorchDispatchModeKey(Enum):
    ...


class _SetExcludeDispatchKeyGuard:
    def __init__(self, k: DispatchKey, enabled: _bool) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info: object) -> None:
        ...
    


class _SchemaInfo:
    def __init__(self, schema: _int) -> None:
        ...
    
    @overload
    def is_mutable(self) -> _bool:
        ...
    
    @overload
    def is_mutable(self, name: str) -> _bool:
        ...
    
    def has_argument(self, name: str) -> _bool:
        ...
    


class BenchmarkConfig:
    num_calling_threads: _int
    num_worker_threads: _int
    num_warmup_iters: _int
    num_iters: _int
    profiler_output_path: str
    ...


class BenchmarkExecutionStats:
    latency_avg_ms: _float
    num_iters: _int
    ...


class ThroughputBenchmark:
    def __init__(self, module: Any) -> None:
        ...
    
    def add_input(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    def run_once(self, *args: Any, **kwargs: Any) -> Any:
        ...
    
    def benchmark(self, config: BenchmarkConfig) -> BenchmarkExecutionStats:
        ...
    


class _ImperativeEngine:
    def queue_callback(self, callback: Callable[[], None]) -> None:
        ...
    
    def run_backward(self, *args: Any, **kwargs: Any) -> tuple[Tensor, ...]:
        ...
    
    def is_checkpoint_valid(self) -> _bool:
        ...
    


class _TensorMeta(type):
    ...


class TensorBase(metaclass=_TensorMeta):
    requires_grad: _bool
    retains_grad: _bool
    shape: Size
    data: Tensor
    names: list[str]
    device: _device
    dtype: _dtype
    layout: _layout
    real: Tensor
    imag: Tensor
    T: Tensor
    H: Tensor
    mT: Tensor
    mH: Tensor
    ndim: _int
    output_nr: _int
    _version: _int
    _base: Tensor | None
    _cdata: _int
    grad_fn: _Node | None
    _grad_fn: Any
    _grad: Tensor | None
    grad: Tensor | None
    _backward_hooks: dict[_int, Callable[[Tensor], Tensor | None]] | None
    nbytes: _int
    itemsize: _int
    _has_symbolic_sizes_strides: _bool
    ...


_TensorBase = TensorBase
class _cuda_CUDAAllocator_AllocatorState:
    ...


class _cuda_CUDAAllocator:
    ...


class _CudaDeviceProperties:
    name: str
    major: _int
    minor: _int
    multi_processor_count: _int
    total_memory: _int
    is_integrated: _int
    is_multi_gpu_board: _int
    max_threads_per_multi_processor: _int
    gcnArchName: str
    warp_size: _int
    uuid: str
    L2_cache_size: _int
    ...


class _SDPAParams:
    query: Tensor
    key: Tensor
    value: Tensor
    attn_mask: Tensor | None
    dropout: _float
    is_causal: _bool
    enable_gqa: _bool
    def __init__(self, query: Tensor, key: Tensor, value: Tensor, attn_mask: Tensor | None, dropout: _float, is_causal: _bool, enable_gqa: _bool) -> None:
        ...
    


class _SDPBackend(Enum):
    ERROR = ...
    MATH = ...
    FLASH_ATTENTION = ...
    EFFICIENT_ATTENTION = ...
    CUDNN_ATTENTION = ...


class _CudaStreamBase(Stream):
    stream_id: _int
    device_index: _int
    device_type: _int
    device: _device
    cuda_stream: _int
    priority: _int
    def __new__(cls, priority: _int = ..., stream_id: _int = ..., device_index: _int = ..., stream_ptr: _int = ...) -> Self:
        ...
    
    def query(self) -> _bool:
        ...
    
    def synchronize(self) -> None:
        ...
    
    def priority_range(self) -> tuple[_int, _int]:
        ...
    


class _CudaEventBase:
    device: _device
    cuda_event: _int
    def __new__(cls, enable_timing: _bool = ..., blocking: _bool = ..., interprocess: _bool = ..., external: _bool = ...) -> Self:
        ...
    
    @classmethod
    def from_ipc_handle(cls, device: _device, ipc_handle: bytes) -> _CudaEventBase:
        ...
    
    def record(self, stream: _CudaStreamBase) -> None:
        ...
    
    def wait(self, stream: _CudaStreamBase) -> None:
        ...
    
    def query(self) -> _bool:
        ...
    
    def elapsed_time(self, other: _CudaEventBase) -> _float:
        ...
    
    def synchronize(self) -> None:
        ...
    
    def ipc_handle(self) -> bytes:
        ...
    


class _CUDAGraph:
    def __new__(cls, keep_graph: _bool = ...) -> Self:
        ...
    
    def capture_begin(self, pool: tuple[_int, _int] | None = ..., capture_error_mode: str = ...) -> None:
        ...
    
    def capture_end(self) -> None:
        ...
    
    def instantiate(self) -> None:
        ...
    
    def register_generator_state(self, Generator) -> None:
        ...
    
    def replay(self) -> None:
        ...
    
    def reset(self) -> None:
        ...
    
    def pool(self) -> tuple[_int, _int]:
        ...
    
    def enable_debug_mode(self) -> None:
        ...
    
    def debug_dump(self, debug_path: str) -> None:
        ...
    
    def raw_cuda_graph(self) -> _int:
        ...
    


class _MemPool:
    def __init__(self, allocator: _cuda_CUDAAllocator | None = ..., is_user_created: _bool = ..., use_on_oom: _bool = ...) -> None:
        ...
    
    @property
    def id(self) -> tuple[_int, _int]:
        ...
    
    @property
    def allocator(self) -> _cuda_CUDAAllocator | None:
        ...
    
    def use_count(self) -> _int:
        ...
    


class _XpuDeviceProperties:
    name: str
    platform_name: str
    vendor: str
    driver_version: str
    version: str
    max_compute_units: _int
    gpu_eu_count: _int
    max_work_group_size: _int
    max_num_sub_groups: _int
    sub_group_sizes: list[_int]
    has_fp16: _bool
    has_fp64: _bool
    has_atomic64: _bool
    has_bfloat16_conversions: _bool
    has_subgroup_matrix_multiply_accumulate: _bool
    has_subgroup_matrix_multiply_accumulate_tensor_float32: _bool
    has_subgroup_2d_block_io: _bool
    total_memory: _int
    gpu_subslice_count: _int
    architecture: _int
    type: str
    ...


class _XpuStreamBase(Stream):
    stream_id: _int
    device_index: _int
    device_type: _int
    device: _device
    sycl_queue: _int
    priority: _int
    def __new__(cls, priority: _int = ..., stream_id: _int = ..., device_index: _int = ..., device_type: _int = ...) -> Self:
        ...
    
    def query(self) -> _bool:
        ...
    
    def synchronize(self) -> None:
        ...
    
    @staticmethod
    def priority_range() -> tuple:
        ...
    


class _XpuEventBase:
    device: _device
    sycl_event: _int
    def __new__(cls, enable_timing: _bool = ...) -> Self:
        ...
    
    def record(self, stream: _XpuEventBase) -> None:
        ...
    
    def wait(self, stream: _XpuStreamBase) -> None:
        ...
    
    def query(self) -> _bool:
        ...
    
    def elapsed_time(self, other: _XpuEventBase) -> _float:
        ...
    
    def synchronize(self) -> None:
        ...
    


class TracingState:
    def push_scope(self, scope_name: str) -> None:
        ...
    
    def pop_scope(self) -> None:
        ...
    
    def current_scope(self) -> str:
        ...
    
    def set_graph(self, graph: Graph) -> None:
        ...
    
    def graph(self) -> Graph:
        ...
    


class IValue:
    ...


Stack: TypeAlias = list[IValue]
class JitType:
    annotation_str: str
    def isSubtypeOf(self, other: JitType) -> _bool:
        ...
    
    def with_dtype(self, dtype: _dtype) -> JitType:
        ...
    
    def with_sizes(self, sizes: list[_int | None]) -> JitType:
        ...
    
    def kind(self) -> str:
        ...
    
    def scalarType(self) -> str | None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    
    def dtype(self) -> _dtype | None:
        ...
    


class InferredType:
    def __init__(self, arg: JitType | str) -> None:
        ...
    
    def type(self) -> JitType:
        ...
    
    def success(self) -> _bool:
        ...
    
    def reason(self) -> str:
        ...
    


class Type(JitType):
    def str(self) -> _str:
        ...
    
    def containedTypes(self) -> list[JitType]:
        ...
    
    def dim(self) -> _int | None:
        ...
    
    def undefined(self) -> _bool | None:
        ...
    
    def sizes(self) -> list[_int] | None:
        ...
    
    def symbol_sizes(self) -> list[_int] | None:
        ...
    
    def varyingSizes(self) -> list[_int | None] | None:
        ...
    
    def strides(self) -> list[_int] | None:
        ...
    
    def contiguous(self) -> Self:
        ...
    
    def device(self) -> _device | None:
        ...
    
    def is_interface_type(self) -> _bool:
        ...
    
    def requires_grad(self) -> _bool:
        ...
    
    @property
    def annotation_string(self) -> _str:
        ...
    


class AnyType(JitType):
    @staticmethod
    def get() -> AnyType:
        ...
    


class NoneType(JitType):
    @staticmethod
    def get() -> NoneType:
        ...
    


class BoolType(JitType):
    @staticmethod
    def get() -> BoolType:
        ...
    


class FloatType(JitType):
    @staticmethod
    def get() -> FloatType:
        ...
    


class ComplexType(JitType):
    @staticmethod
    def get() -> ComplexType:
        ...
    


class IntType(JitType):
    @staticmethod
    def get() -> IntType:
        ...
    


class SymIntType(JitType):
    @staticmethod
    def get() -> SymIntType:
        ...
    


class SymBoolType(JitType):
    @staticmethod
    def get() -> SymBoolType:
        ...
    


class NumberType(JitType):
    @staticmethod
    def get() -> NumberType:
        ...
    


class StringType(JitType):
    @staticmethod
    def get() -> StringType:
        ...
    


class DeviceObjType(JitType):
    @staticmethod
    def get() -> DeviceObjType:
        ...
    


class _GeneratorType(JitType):
    @staticmethod
    def get() -> _GeneratorType:
        ...
    


class StreamObjType(JitType):
    @staticmethod
    def get() -> StreamObjType:
        ...
    


class ListType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    
    @staticmethod
    def ofInts() -> ListType:
        ...
    
    @staticmethod
    def ofTensors() -> ListType:
        ...
    
    @staticmethod
    def ofFloats() -> ListType:
        ...
    
    @staticmethod
    def ofComplexDoubles() -> ListType:
        ...
    
    @staticmethod
    def ofBools() -> ListType:
        ...
    
    @staticmethod
    def ofStrings() -> ListType:
        ...
    


class DictType(JitType):
    def __init__(self, key: JitType, value: JitType) -> None:
        ...
    
    def getKeyType(self) -> JitType:
        ...
    
    def getValueType(self) -> JitType:
        ...
    


class TupleType(JitType):
    def __init__(self, a: list[JitType | None]) -> None:
        ...
    
    def elements(self) -> list[JitType]:
        ...
    


class UnionType(JitType):
    def __init__(self, a: list[JitType]) -> None:
        ...
    


class ClassType(JitType):
    def __init__(self, qualified_name: str) -> None:
        ...
    
    def qualified_name(self) -> str:
        ...
    


class InterfaceType(JitType):
    def __init__(self, qualified_name: str) -> None:
        ...
    
    def getMethod(self, name: str) -> FunctionSchema | None:
        ...
    
    def getMethodNames(self) -> list[str]:
        ...
    


JitTypeT = TypeVar("JitTypeT", bound=JitType)
class OptionalType(JitType, Generic[JitTypeT]):
    def __init__(self, a: JitTypeT) -> None:
        ...
    
    def getElementType(self) -> JitTypeT:
        ...
    
    @staticmethod
    def ofTensor() -> OptionalType:
        ...
    


class FutureType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    


class AwaitType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    


class RRefType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    


class EnumType(JitType):
    def __init__(self, qualified_name: str, value_type: JitType, enum_names_values: list[Any]) -> None:
        ...
    


class TensorType(JitType):
    @classmethod
    def get(cls) -> TensorType:
        ...
    
    @classmethod
    def getInferred(cls) -> TensorType:
        ...
    
    def with_sizes(self, other: list[_int | None] | None) -> TensorType:
        ...
    
    def sizes(self) -> list[_int] | None:
        ...
    
    def varyingSizes(self) -> list[_int | None] | None:
        ...
    
    def strides(self) -> list[_int] | None:
        ...
    
    def device(self) -> _device | None:
        ...
    
    def dim(self) -> _int:
        ...
    
    def dtype(self) -> _dtype | None:
        ...
    
    @staticmethod
    def create_from_tensor(t: Tensor) -> TensorType:
        ...
    


class SourceRange:
    ...


class TreeView:
    ...


class Ident(TreeView):
    @property
    def name(self) -> str:
        ...
    


class ClassDef(TreeView):
    ...


class Def(TreeView):
    def name(self) -> Ident:
        ...
    


class Decl(TreeView):
    ...


class AcceleratorError(RuntimeError):
    ...


class OutOfMemoryError(RuntimeError):
    ...


class _DistError(RuntimeError):
    ...


class _DistBackendError(RuntimeError):
    ...


class _DistStoreError(RuntimeError):
    ...


class _DistNetworkError(RuntimeError):
    ...


class _DistQueueEmptyError(_DistStoreError):
    ...


class CapturedTraceback:
    ...


def gather_traceback(python: _bool, script: _bool, cpp: _bool) -> CapturedTraceback:
    ...

def symbolize_tracebacks(tracebacks: list[CapturedTraceback]) -> list[dict[str, Any]]:
    ...

class _NodeBase:
    _erased: _bool
    _prev: FxNode
    _next: FxNode
    def __init__(self, graph: Any, name: str, op: str, target: Any, return_type: Any) -> None:
        ...
    


class _NodeIter(Iterator[FxNode]):
    def __init__(self, root: FxNode, reversed: _bool) -> None:
        ...
    
    def __iter__(self) -> Self:
        ...
    
    def __next__(self) -> FxNode:
        ...
    


class _StaticCudaLauncher:
    ...


