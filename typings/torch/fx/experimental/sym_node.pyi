"""
This type stub file was generated by pyright.
"""

from typing import Optional, TYPE_CHECKING, Union
from torch.fx.experimental.symbolic_shapes import ShapeEnv

if TYPE_CHECKING:
    ...
log = ...
sym_node_log = ...
__all__ = ["SymNode", "method_to_operator", "magic_methods"]
class SymNode:
    """
    This is a type erased SymInt/SymFloat which we use to do actual operations.
    End users don't touch this.  Magic methods are NOT defined on this object.
    """
    _optimized_summation: bool = ...
    def __init__(self, expr, shape_env, pytype, hint: Optional[Union[int, float, bool]], constant=..., fx_node=..., optimized_summation=...) -> None:
        ...
    
    def with_shape_env(self, shape_env: ShapeEnv) -> SymNode:
        ...
    
    @property
    def expr(self):
        ...
    
    @property
    def hint(self): # -> int | float | bool | None:
        ...
    
    def has_hint(self): # -> bool:
        ...
    
    def require_hint(self, fallback=...): # -> int | float | bool:
        ...
    
    def maybe_as_int(self): # -> int | None:
        ...
    
    def maybe_as_float(self): # -> float | None:
        ...
    
    def maybe_as_bool(self): # -> bool | None:
        ...
    
    def is_int(self): # -> bool:
        ...
    
    def is_float(self): # -> bool:
        ...
    
    def is_bool(self): # -> bool:
        ...
    
    def is_nested_int(self): # -> Literal[False]:
        ...
    
    def wrap_int(self, num): # -> SymNode:
        ...
    
    def wrap_float(self, num): # -> SymNode:
        ...
    
    def wrap_bool(self, num): # -> SymNode:
        ...
    
    def clone(self): # -> Self:
        ...
    
    def str(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def abs(self) -> SymNode:
        ...
    
    def pos(self) -> SymNode:
        ...
    
    def round(self, ndigits=...) -> SymNode:
        ...
    
    def trunc(self) -> SymNode:
        ...
    
    def add(self, other) -> SymNode:
        ...
    
    def sub(self, other) -> SymNode:
        ...
    
    def mul(self, other) -> SymNode:
        ...
    
    def mod(self, other) -> SymNode:
        ...
    
    def float_pow(self, other) -> SymNode:
        ...
    
    def pow_by_natural(self, other) -> SymNode:
        ...
    
    def and_(self, other) -> SymNode:
        ...
    
    def or_(self, other) -> SymNode:
        ...
    
    def float_truediv(self, other) -> SymNode:
        ...
    
    def int_truediv(self, other) -> SymNode:
        ...
    
    def int_floordiv(self, other) -> SymNode:
        ...
    
    def lshift(self, other) -> SymNode:
        ...
    
    def rshift(self, other) -> SymNode:
        ...
    
    def sym_not(self) -> SymNode:
        ...
    
    def eq(self, other) -> SymNode:
        ...
    
    def ne(self, other) -> SymNode:
        ...
    
    def gt(self, other) -> SymNode:
        ...
    
    def lt(self, other) -> SymNode:
        ...
    
    def le(self, other) -> SymNode:
        ...
    
    def ge(self, other) -> SymNode:
        ...
    
    def floor(self) -> SymNode:
        ...
    
    def is_integer(self) -> SymNode:
        ...
    
    def sym_float(self) -> SymNode:
        ...
    
    def sym_int(self) -> SymNode:
        ...
    
    def ceil(self) -> SymNode:
        ...
    
    def neg(self) -> SymNode:
        ...
    
    def sym_min(self, other) -> SymNode:
        ...
    
    def sym_max(self, other) -> SymNode:
        ...
    
    def sym_ite(self, then_val, else_val) -> SymNode:
        ...
    
    def is_contiguous(self, sizes, strides) -> SymNode:
        ...
    
    def is_channels_last_contiguous_2d(self, sizes, strides) -> SymNode:
        ...
    
    def is_channels_last_contiguous_3d(self, sizes, strides) -> SymNode:
        ...
    
    def is_channels_last_strides_2d(self, sizes, strides) -> SymNode:
        ...
    
    def is_channels_last_strides_3d(self, sizes, strides) -> SymNode:
        ...
    
    def is_non_overlapping_and_dense_indicator(self, sizes, strides) -> SymNode:
        ...
    
    def sym_or(self, other): # -> SymNode:
        ...
    
    def sym_and(self, other): # -> SymNode:
        ...
    
    def bitwise_and(self, other):
        ...
    
    def bitwise_or(self, other):
        ...
    
    def truediv(self, other): # -> SymNode:
        ...
    
    def floordiv(self, other) -> SymNode:
        ...
    
    def pow(self, other): # -> SymNode:
        ...
    
    def is_non_overlapping_and_dense(self, sizes, strides): # -> SymNode:
        ...
    
    def int_(self): # -> int:
        ...
    
    def sym_sum(self, args) -> SymNode:
        ...
    
    def evaluate(self, size_oblivious=...):
        ...
    
    def guard_int(self, file, line): # -> int:
        ...
    
    def guard_float(self, file, line): # -> float:
        ...
    
    def guard_bool(self, file, line): # -> bool:
        ...
    
    def expect_true(self, file, line): # -> bool:
        ...
    
    def expect_size(self, file, line): # -> bool:
        ...
    
    def statically_known_true(self, file, line): # -> bool:
        ...
    
    def guard_size_oblivious(self, file, line): # -> bool:
        """
        Like guard_bool, but if we encounter unbacked symbols, if those symbols
        are size-like, we will treat them as >= 2 for the purposes of the analysis.

        This CHANGES the runtime semantics, but all size-oblivious sites have been
        audited to ensure that the runtime semantics don't change in a material way.
        Acceptable runtime semantic changes are, e.g., squeeze() no longer dropping
        an unbacked one size, or a tensor reporting as non-contiguous even if it's
        contiguous if it would have been reported contiguous due to being empty.
        """
        ...
    
    def guard_or_false(self, file, line): # -> bool:
        ...
    
    def guard_or_true(self, file, line): # -> bool:
        ...
    
    def bool_(self): # -> bool:
        ...
    
    def is_symbolic(self): # -> Literal[True]:
        ...
    
    def nested_int(self): # -> None:
        ...
    
    def is_constant(self): # -> Literal[False]:
        ...
    


METHOD_TO_OPERATOR = ...
unary_magic_methods = ...
math_op_names = ...
unary_nonmagic_methods = ...
unary_methods = ...
only_bool_magic_methods = ...
bool_becomes_int_magic_methods = ...
also_bool_magic_methods = ...
bool_magic_methods = ...
only_float_magic_methods = ...
magic_methods_on_operator_with_trailing_underscore = ...
bitwise_ops = ...
always_float_magic_methods = ...
always_int_magic_methods = ...
always_bool_magic_methods = ...
reflectable_magic_methods = ...
current_module = ...
magic_methods = ...
def sympy_is_contiguous(sizes, strides): # -> BooleanFalse | BooleanTrue | Boolean:
    ...

def sympy_is_contiguous_generic(sizes, strides, dim_order): # -> BooleanFalse | BooleanTrue | Boolean:
    ...

def sympy_is_channels_last_contiguous_2d(sizes, strides): # -> BooleanFalse | BooleanTrue | Boolean:
    ...

def sympy_is_channels_last_contiguous_3d(sizes, strides): # -> BooleanFalse | BooleanTrue | Boolean:
    ...

def sympy_is_channels_last_strides_generic(sizes, strides, dim_order): # -> BooleanFalse | Boolean:
    ...

def sympy_is_channels_last_strides_2d(sizes, strides): # -> BooleanFalse | Boolean:
    ...

def sympy_is_channels_last_strides_3d(sizes, strides): # -> BooleanFalse | Boolean:
    ...

sizes_strides_methods = ...
def to_node(self, num): # -> _NotImplementedType:
    ...

def wrap_node(x): # -> int | float | bool | SymInt | SymFloat | SymBool:
    ...

def method_to_operator(method):
    ...

