"""
This type stub file was generated by pyright.
"""

from torch._C import DispatchKey
from torch._ops import HigherOrderOperator
from torch._subclasses.fake_tensor import FakeTensorMode
from torch.fx.experimental.proxy_tensor import ProxyTorchDispatchMode

class ExportTracepoint(HigherOrderOperator):
    def __init__(self) -> None:
        ...
    
    def __call__(self, *args, **kwargs): # -> Any | None:
        ...
    


_export_tracepoint = ...
@_export_tracepoint.py_impl(ProxyTorchDispatchMode)
def export_tracepoint_dispatch_mode(mode, *args, **kwargs): # -> tuple[Any, ...]:
    ...

@_export_tracepoint.py_impl(FakeTensorMode)
def export_tracepoint_fake_tensor_mode(mode, *args, **kwargs): # -> tuple[Any, ...]:
    ...

@_export_tracepoint.py_functionalize_impl
def export_tracepoint_functional(ctx, *args, **kwargs): # -> tuple[Any, ...]:
    ...

@_export_tracepoint.py_impl(DispatchKey.CPU)
def export_tracepoint_cpu(*args, **kwargs): # -> tuple[Any, ...]:
    ...

def mark_subclass_constructor_exportable_experimental(constructor_subclass): # -> Callable[..., None]:
    """
    Experimental decorator that makes subclass to be traceable in export
    with pre-dispatch IR. To make your subclass traceble in export, you need to:
        1. Implement __init__ method for your subclass (Look at DTensor implementation)
        2. Decorate your __init__ method with _mark_constructor_exportable_experimental
        3. Put torch._dynamo_disable decorator to prevent dynamo from peeking into its' impl

    Example:

    class FooTensor(torch.Tensor):
        @staticmethod
        def __new__(cls, elem, *, requires_grad=False):
            # ...
            return torch.Tensor._make_subclass(cls, elem, requires_grad=requires_grad)

        @torch._dynamo_disable
        @mark_subclass_constructor_exportable_experimental
        def __init__(self, elem, ...):
            # ...
    """
    ...

